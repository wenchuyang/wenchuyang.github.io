{"meta":{"title":"夜落初阳","subtitle":null,"description":"文初阳的个人博客","author":"文初阳","url":"http://yoursite.com","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2022-11-25T06:28:53.832Z","updated":"2022-11-25T06:28:53.832Z","comments":false,"path":"/404.html","permalink":"http://yoursite.com//404.html","excerpt":"","text":""},{"title":"关于","date":"2022-11-25T06:40:26.699Z","updated":"2022-11-25T06:28:53.839Z","comments":false,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"做一个优秀的人，做一个快乐的人。 姓名: 文初阳居住地: HangZhou, Chinagithub: wenchuyangCSDN: 文初阳"},{"title":"分类","date":"2022-11-25T06:28:53.839Z","updated":"2022-11-25T06:28:53.839Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-11-25T06:28:53.839Z","updated":"2022-11-25T06:28:53.839Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"同源策略的理解","slug":"同源策略的理解","date":"2022-12-07T01:14:21.000Z","updated":"2022-12-07T14:53:33.278Z","comments":true,"path":"2022/12/07/同源策略的理解/","link":"","permalink":"http://yoursite.com/2022/12/07/同源策略的理解/","excerpt":"","text":"什么叫同源协议域名端口号三者相同则为同源。拿 http://www.baidu.com 举例： https://www.baidu.com 不同源，协议不同、端口号不同（ http 默认端口号为 80，https 默认端口号为 443 ） http://baidu.com 不同源，域名不同 http://www.baidu.com:81 不同源，端口号不同( http 协议默认端口号为 80) http://www.baidu.com/index 同源，后面的 /index 是域名下的文件夹，不作为同源判断依据 什么是同源策略1995 年，同源策略由 Netscape 公司引入浏览器。目前，所有浏览器都实行这个策略。浏览器的同源策略实际是想要限制两个不同源的网站交互。它想要达成的目标是：在用户访问恶意网站的时候，这个恶意网站无法影响到用户与正常网站之间的交互。为了遵循同源策略衍生出来了三种不同的限制： 限制不同源的网站读取 Cookie, LocalStorage, indexDB 限制不同源的网站读取 DOM 限制不同源的网站发送 AJAX 请求但由于万维网的诞生就是为了做资源的链接共享，所以完全限制两个网站之间的交互是不现实的，因此浏览器的目标是控制这个交互的受控。所以我们可以看到，浏览器的同源策略不针对一些纯粹的对资源的操作，比如 img、link、script 等标签的资源引进操作，比如 a 标签的点击跳转。另外，对于 form 表单的提交，同源策略同样不做限制，同源策略只针对读操作，也因此对于 ajax 请求，其实是能够正常发送的，但是浏览器阻止了资源的接收。对于同源策略限制的以上三点，单独分析的话： 浏览器本地保存了用户的隐私信息，假设恶意网站能够随意读取其他网站的 Cookie 的话，就可以模仿用户登录进而拿到用户的隐私信息。 限制不同源的网站读取 DOM 主要是为了防止恶意网站通过 iframe 调用被攻击网站，等到用户在 iframe 里输入了用户名和密码之后，恶意网站再拿到 iframe 的 DOM 节点中输入的用户名密码，从而获取用户的隐私信息。 ajax 请求的限制源于它的自由度，它可以支持任意请求的发送，也可以拿到网站的响应信息。如果不限制 ajax 的话，那么用户在登录了 A 网站后，再进入 B 网站，B 网站虽然不能直接拿到 A 网站的 Cookie，但是在它向 A 网站发送请求的时候，会携带 A 网站的 Cookie，免除了登录步骤。B 网站就可以通过这种方法拿到 A 网站的用户隐私信息。 规避同源的方法同源策略对不同源的网站之间的通信做出了诸多的限制，但实际使用中又存在需要跨域的情况，因此就有了“规避同源的方法”这个需求。在这个基础上，一方面是开发者通过一些“特性”来规避同源策略，另一方面 W3C 也提供了一些方法来做不同源之间的通信。这里列举一部分。 JSONPjsonp 利用 script 标签不受同源策略限制的漏洞，通过动态创建 script 标签，并把 src 指向目标地址的方式发送请求，通过服务器调用 callback 来获取响应。具体实现 点这里 window.postMessageHTML5 引入了跨文档通信 API，A 网站通过 window.postMessage(&#39;message&#39;, &#39;http://B.com&#39;) 向 B 网站发送请求，B 网站通过监听 message 事件来拿到消息。 CORS跨域资源共享是 W3C 提供的一种解决 AJAX 跨域问题的方法，通过设置 HTTP 响应头 Access-Control-Allow-Origin 来指定哪些源可以对该资源进行跨域访问来解决同源问题。相当于告诉浏览器这个来源是自己人，可以让它进行访问。这其实在一方面印证了上面所说的，浏览器并不限制 ajax 请求的发送，它限制的是响应的读取。CORS 相关的详细可访问阮一峰老师的这篇文章来查看。 nginx 反向代理nginx 是利用反向代理对同源策略的一种规避。首先了解一下什么是代理，试想一个场景：用户想要访问 google.com ，但是因为安全上网策略无法访问，所以挂了个代理，代理拦截了用户发的请求，然后转发给 google.com，google.com 发送响应给代理服务器，接着代理服务器又返回给用户，这就完成一次正向代理的过程。正向代理其实是，我知道我要去 A 商店买东西，但是我找不到路，那么正向代理拿着我的钱去了 A 商店，然后又把货物给我运了回来。而反向代理则是，我想要买东西，但是我不在乎去哪里买，我只要找到这个反向代理，把钱给他，然后让他把货物给我。因为同源策略限制的只是不同源的网站之间的交互，服务器向服务器发请求，这个过程是不受同源策略限制的。所以 nginx 做的操作是：它把 origin 设置为和网站一致，然后接收网站发来的请求，再去向服务器发请求，拿到服务器的响应后，又把响应返回给网站。 参考资料MDN 浏览器的同源策略阮一峰 浏览器同源政策及其规避方法JavaScript GuideBookW3C same origin policy浏览器安全手册同源策略草案同源策略的分析随笔","categories":[{"name":"计算机","slug":"计算机","permalink":"http://yoursite.com/categories/计算机/"},{"name":"前端","slug":"计算机/前端","permalink":"http://yoursite.com/categories/计算机/前端/"}],"tags":[{"name":"网络安全","slug":"网络安全","permalink":"http://yoursite.com/tags/网络安全/"}]},{"title":"src和href的区别","slug":"src和href的区别","date":"2022-12-01T13:07:57.000Z","updated":"2022-12-02T16:37:08.393Z","comments":true,"path":"2022/12/01/src和href的区别/","link":"","permalink":"http://yoursite.com/2022/12/01/src和href的区别/","excerpt":"","text":"定义 src 指的是 source，用来内联一个额外的文件，比如 &lt;img src=&#39;a.png&#39; /&gt; 就是下载 a.png , 然后把它放到这个位置上来。 href 全称是 hypertext reference, 超文本引用，一般是用来建立当前文档和外部文档的一个联系，相当于一个桥梁的作用。比如 &lt;a href=&#39;https://www.baidu.com&#39;&gt;上网&lt;/a&gt;, 点击这个超文本就能顺着它到外部文档上去。 link 和 script这两个标签分别是用来引入 css 和 js 的，分别用到了 href 和 src 属性，这里之所以拿出来单独讲是因为就我个人而言上面的定义没法说服我理解这两个标签。讲之前先简单地提一下浏览器的渲染过程：加载 HTML -&gt; 解析 HTML 以构建 DOM 树 -&gt; 发请求下载 DOM 链接的资源 -&gt; 确定渲染规则构建 render 树 -&gt; 将 style 应用到 DOM 节点上(布局 render 树) -&gt; 渲染页面(绘制 render 树)在我们输入 URL 之后，浏览器会向服务器发送请求，服务器返回的一般是一个 HTML，浏览器拿到这个 HTML 文件之后开始做解析开始构建 DOM 树。浏览器是从上往下一行一行解析的，在遇到需要做资源请求的时候就继续向服务器发请求。link 和 script 的不同点在于，link 发了请求之后就继续解析下一行，而 script 发了请求之后，就在等待请求的返回结果，然后执行 js 语句。执行完 js 语句之后，再去解析下一行。也因此如果内嵌 script 的话，最好是放在文档结尾，一般在 body 结束标签的上方（因为 body 标签下面的可能会被部分浏览器忽略）；而内嵌 style 的话都是放在文档头部，head 结束标签的上方。但实际上我们在 html 里面写如下一段代码会发现链接的几个资源是同时下载的，并没有出现阻塞的情况。12345&lt;link rel=&quot;stylesheet&quot; href=&quot;./styles.css&quot; /&gt;&lt;script src=&quot;./index.js&quot;&gt;&lt;/script&gt;&lt;img src=&quot;1.jpg&quot; /&gt;&lt;div id=&quot;app&quot;&gt;111&lt;/div&gt;&lt;script src=&quot;./index2.js&quot;&gt;&lt;/script&gt; 这是因为浏览器的预加载机制，在浏览器解析并构建 DOM 树的时候，预加载扫描仪同时扫描文档并请求高优先级资源，它的存在减少了 script 标签带来的阻塞。但这并不影响它的主流程：解析 HTML 的时候遇到 script 标签会执行完里面的脚本再继续解析下一行。 linklink 的特殊之处在于，虽然它使用的是 href，但是它是会主动下载它链接的资源的。相比之下 a 标签其实只是做了一个链接，并不会主动去发送请求。另外想要提的一点就是 CSS 是渲染阻塞的：浏览器会阻塞页面渲染直到它接收和执行了所有的 CSS。CSS 是渲染阻塞是因为规则可以被覆盖，所以内容不能被渲染直到 CSSOM 的完成。但是它不阻塞 DOM 的加载，而且 DOM 的构建是一点一点往页面上 push 的。 scriptscript 和 img 相比较而言，img 不会阻塞加载，只是做资源请求。在 HTML5 中，script 标签添加了两个属性：async 和 defer，可以用来控制是否做内容的阻塞。如果添加了 async，那么会异步加载这个 script 引入的资源，在资源获取完成的时候执行脚本，与浏览器当前解析到哪里无关；如果添加了 defer，那么会等到页面全部解析完成之后再去加载这个 script 引入的资源（在预加载的情况下会预加载，但还是会放到最后执行加载进来的 js ）；如果都没有添加的话，就是前面说的先获取资源执行脚本，再解析下一行。之前默认阻塞是因为 js 是可以操作 DOM 的，所以 js 的执行顺序其实是会影响页面布局，在添加了这两个属性之后相当于其中的风险由开发者控制，在没有必要的时候不需要让它阻塞流程。 参考资料stack overflow: difference between src and hrefMDN: 什么是 JavaScriptMDN: 渲染页面：浏览器的工作原理MDN: How CSS worksMDN: 关键渲染路径","categories":[{"name":"计算机","slug":"计算机","permalink":"http://yoursite.com/categories/计算机/"},{"name":"前端","slug":"计算机/前端","permalink":"http://yoursite.com/categories/计算机/前端/"},{"name":"HTML","slug":"计算机/前端/HTML","permalink":"http://yoursite.com/categories/计算机/前端/HTML/"}],"tags":[{"name":"面试","slug":"面试","permalink":"http://yoursite.com/tags/面试/"}]},{"title":"nvm 的安装使用","slug":"nvm的安装使用","date":"2022-12-01T06:00:09.000Z","updated":"2022-12-01T06:34:14.716Z","comments":true,"path":"2022/12/01/nvm的安装使用/","link":"","permalink":"http://yoursite.com/2022/12/01/nvm的安装使用/","excerpt":"","text":"nvm 是什么node version manager , node 版本管理器，是用来管理 node 版本的，让你可以在你的电脑上同时安装多个 node 版本。 下载安装 nvm 上nvm 官网下载安装 命令行输入 nvm -v 查看 nvm 是否安装成功 在你的用户目录下新建 .bash_profile 文件：touch ~/.bash_profile。（如果有的话就打开文件。） 在 .bash_profile 文件内写入： 12export NVM_DIR=&quot;$HOME/.nvm&quot;[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; \\. &quot;$NVM_DIR/nvm.sh&quot; # This loads nvm 命令行执行 source ~/.bash_profile，然后再看 nvm 有没有安装成功。 用 nvm 管理 node nvm list 查看已安装的 node。 nvm install v18.12.1 安装指定版本的 node，此时如果报 permission denied 等权限问题就用管理员模式打开 git bash 再执行命令。 nvm use 18.12.1 使用指定版本 node，再次 ls 的时候使用的版本前面会带有一个 * 号。 npm not found 的问题 打开你的 nvm 安装地址，可以看见有带 node 版本号的文件夹。 打开node 下载地址，下载你需要的 node 版本。 把你自己下载的 node 解压到对应版本号里面，然后再看你的 npm -v 能不能用。 参考资料Windows 上安装 NVM 之后找不到 NPM 的解决办法nvm：安裝、切換不同 Node.js 版本的管理器","categories":[{"name":"计算机","slug":"计算机","permalink":"http://yoursite.com/categories/计算机/"}],"tags":[{"name":"nvm","slug":"nvm","permalink":"http://yoursite.com/tags/nvm/"},{"name":"工具使用","slug":"工具使用","permalink":"http://yoursite.com/tags/工具使用/"}]},{"title":"前端历史","slug":"前端历史","date":"2022-11-25T06:42:09.000Z","updated":"2022-11-30T11:16:16.983Z","comments":true,"path":"2022/11/25/前端历史/","link":"","permalink":"http://yoursite.com/2022/11/25/前端历史/","excerpt":"","text":"一切的起点事情起源于信息共享。Tim Berners-Lee 受命开发一套软件系统，供 CERN 研究人员分享、更新、查阅研究报告。超文本（HyperText）是 Ted Nelson 在 1965 年提出来的一个概念，不同的信息之间用超文本链接起来，点击就可以进入这个信息结点，而李爵士设计的万维网，就是这个概念的实现。万维网的核心部分是由三个标准构成的：统一资源定位符（URL），根据统一资源定位符，可以找到这个资源。超文本传送协议（HTTP），规定客户端和服务器怎样交流，允许用户通过 URL 访问资源。超文本标记语言（HTML），定义超文本文档的结构和格式。浏览器、服务器、超文本传输协议，这三者就是前端最初的模样。因为万维网的创建就是为了文档共享，所以你可以看到 HTML 本质上就是一个 document，所以初代 HTTP 协议只规定了 GET 请求，响应格式也只支持 HTML。而你也很容易就能理解为什么 HTTP 是一个无状态的协议，因为它的诞生就是为了请求文档，因为互联网的精神是共享。 相关概念URI 和 URL每个信息都有唯一的统一资源标识符 URI (uniform resource identifier)，相当于我们的身份证号；同时，每个信息还有唯一的统一资源定位符 URL (uniform resource locator)，相当于唯一的家庭住址。只要输入 URL，就能够根据 URL 就能找到这条信息。与之相关的概念还有统一资源命名 URN (uniform resource name)，通过名字来唯一标识资源。URI 是一种抽象的概念，而 URL 和 URN 都是这个概念的具象化。也因此，在一些场景中，你可以把 URI 同化为 URL。但实际上，URL 和 URN 都是 URI 的子集。 HTTPHTTP 全称是 Hypertext Transfer Protocol，超文本传输协议，是基于 TCP/IP 的应用层协议，采用 BS 架构（浏览器-服务器架构），规定了客户端和服务器的通信格式，默认使用 80 端口。客户端按照这个格式发送请求，服务器端按照这个格式解析请求并以此格式发送响应。 HTMLHTML 全称是 Hyper Text Markup Language ，超文本标记语言，不论是超文本，还是标记语言，都是早已有之的概念。前面提到过超文本，你可以简单地把它理解为 a 标签。至于标记语言，在最早的时候是出版业的一个概念，在文字打印的时候做一些标记，字体字号，加黑居中等等。这一点我们仍旧可以在现在的 HTML 中看到，文件开头用 doctype 声明文档类型让浏览器用正确的方法来解析这个文件，文件内用各种标签让浏览器以不同的逻辑来做渲染，使这个页面正确地展示在我们面前。 HTTP 的历史 1991 年，伴随着万维网的亮相，初代 HTTP 也走入了大众的视野，在后来的 HTTP 发展史中，称它为 HTTP/0.9。在这个版本中，只能发布 GET 请求，规定服务器返回 HTML 格式的字符串。 1995 年初成立了 HTTP 工作组，称为 HTTP WG , 由 Dave Raggett 领导，标准化和扩展化该协议，并把它们记录为官方 RFC。 1996 年 5 月，HTTP/1.0 发布，增加了 POST 命令和 HEAD 命令，可以发送任何格式的内容，并且改变了 HTTP 请求和响应的格式，新增了 HTTP header，用来描述元数据，并且增加了响应的状态码。事实上，在 HTTP/1.0 发布之前，未正式发布的 HTTP/1.0-draft 已经被很多浏览器和服务器使用了。 1997 年 1 月，时隔半年，HTTP/1.1 发布，加入了持久化连接，建立 TCP 连接之后保持一段时间的连接，可以让一个 TCP 连接被多个请求复用，提高请求的效率。另外除了原有的 POST 和 GET 外，还增加了很多请求方法，PUT、PATCH、HEAD、OPTIONS、DELETE。HTTP/1.1 2015 年，HTTP/2 发布，HTTP/2 主要的目标是提高请求的速度，减少请求时间。为此增加了二进制分帧、多路复用、服务器推送、头部压缩等新特性。只用于 HTTPS 加密连接。HTTPS 指的是，在 HTTP 协议的基础上套接一层 SSL 做数据的加密。SSL(Secure Socket Layer) 安全套接层，在 TCP/IP 四层概念模型（应用层、传输层、网络层、数据链路层）中介于应用层和传输层之间，应用层数据不直接传递给传输层，而是传递给 SSL 层，经过加密之后再进行传输。 2022 年，HTTP/3 发布。在 HTTP/2 中采用了多路复用来解决 TCP 的队头阻塞问题，但即使是多路，在每个队头仍然存在少见的队头阻塞问题，因此 HTTP/3 决定不再使用 TCP/IP 连接，而是使用 QUIC + UDP。从 HTTP 的发展我们可以看见，它从一开始就是为了解决实际问题出现的。它的诞生是为了传输 HTML 文件；随着 web 的发展，人们需要传输更多类型的文件，需要各种标识，所以有了 HTTP/1.1；而在满足基本的传输需求之后，随之而来的性能和安全问题也被提上了日程，因此有了接下来的 HTTP/2 、 HTTP/3 以及 HTTPS。 HTML 的历史 1990 年，HTML 伴随着 WWW 的诞生而诞生。 1994 年 10 月，W3C 成立，负责维护和制定 web 相关的标准。 1995 年 11 月，HTML 2.0，在 2000 年 6 月被宣布过时。 1996 年 1 月，HTML 3.2。 1997 年 11 月，HTML 4.0。 1999 年 12 月，HTML 4.01 以 XML 语法重新构建，比之前严格。值得一提的是，W3C 在随后的 2000 年 1 月，就推出了 XHTML1.0 ，试图以严格的语法和极低的容错性规范已存在的种种不规范的行为。在那之后的 2001 年 5 月，又发布了 XHTML 1.1。 2004 年，各大浏览器开发商组成了 WHATWG 小组，在 HTML 4.01 的基础上继续开发 HTML 5。 2006 年，W3C 放弃 XHTML 2.0。 2007 年，W3C 参考 WHATWG 拟定的 HTML 5 继续发展 HTML。 2014 年 10 月，W3C 正式发布 HTML 5.0。 CSS 的发展在很早以前，我刚学前端的时候听说过一句话，大致意思是：如果说 HTML 是网页的骨架，那么 CSS 就是它的皮囊。在我当时的理解里，前端就是 HTML + CSS + JS ，结构、表现和行为，他们控制着我们面前的网页。把目光拉远，才发现原来应该是浏览器 + 服务器 + 传输协议，当然这是后话，定义总是会让它变得狭隘，君子不器。总的来说，CSS 在前端页面中扮演着点缀的作用，它丰富了样式，控制着网页的外观。从 HTML 诞生伊始，就已经有了 CSS 的雏形。但当时 CSS 还不是 CSS，只是样式。李爵士当时的想法是在浏览器端以一个简单的样式表实现样式，这样每个浏览器都可以决定如何更好地向用户展示页面，而他当时也是这样编写他的第一个浏览器的。只能说，结构与样式分离的思想一直都在，只是从浏览器，转换到了网页上。 1994 年 10 月，Hakon Wium Lie 发布了Cascading HTML style sheets初稿。Bert Bos 对这份初稿做出了回应，当时他正在开发 Argo 浏览器——一个带有样式表的高度可定制浏览器。Argo 的一个目标是可以兼容除 HTML 外的其它标记语言，而这也成为了 CSS 的目标，因此 Cascading HTML style sheets 变成了 Cascading style sheets。 1995 年，W3C 参与 CSS 规范的制定，在一次研讨会上，Microsoft 的 Thomas Reardon 承诺在即将推出的 Internet Explorer 版本中支持 CSS。而在 1995 年年底，Netscape 的 Lou Montulli 也加入了在浏览器上支持 CSS 的计划。 1996 年 12 月，W3C 推出了 CSS 1。 1998 年 5 月，W3C 发布 CSS2。 2004 年 2 月，推出 CSS2.1，修改了 CSS2 中的一些错误，并增加一些扩展内容。 2011 年 6 月，CSS3 推出，与之前的 CSS 版本不同的是，CSS3 被分为了多个模块单独升级，统称为 CSS3。 2011 年 6 月，CSS3 Color Module 发布；同年 9 月，Selectors 和 Namespaces 发布；2012 年 6 月，Media Queries 发布…… JavaScript 的发展Netscapt Navigator 浏览器如日中天的时候，为了控制浏览器行为，避免不必要的服务器连接操作，JavaScript 作为可嵌入网页的脚本语言应运而生。 1995 年 5 月，Brendan Eich 设计完成了第一版，叫做 Mocha，1995 年 9 月改为 LiveScript，同年 12 月，改名为 JavaScript，试图借着 Java 的声势推广开来。 1996 年 3 月，Netscape Navigator 2.0 正式内置了 JavaScript。此时仍旧是 Netscape 与微软的浏览器大战期间，1996 年 8 月，不甘示弱的微软模仿 JavaScript 开发了 JScript，内置于 IE 3.0。 1996 年 11 月，Netscape 决定将 JavaScript 提交给国际标准化组织 ECMA (European Computer Manufacturers Association)，希望 JavaScript 能成为国际标准。 1997 年 7 月，ECMA 发布 ECMA-262 的第一版（ECMAScript 1.0），规定了浏览器脚本语言的标准，并将这种语言称为 ECMAScript。因此，ECMAScript 是 JavaScript 的标准，而后者是前者的实现。而事实上，JavaScript 不仅仅实现了 ECAMScript，还同时包含了 DOM (Document Object Model, 文档对象模型) 和 BOM (Browser Object Model, 浏览器对象模型)，DOM 用于提供与网页内容进行交互的方法和接口，BOM 用于提供与浏览器内容进行交互的方法和接口。网页从此不再是单纯的一个展示页面了。 1998 年 6 月，ECMAScript 2.0 发布。 1999 年 12 月，ECMAScript 3.0 发布，得到了广泛支持。而 ECMAScript 4.0 因为过于激进被废除，部分功能在 2008 年 7 月发布为 ECMAScript 3.1。 2009 年 12 月，ECMAScript 5.0 发布。 2011 年 6 月，ECMAScript 5.1 发布，并且成为 ISO 国际标准。2012 年底，所有主要浏览器都支持 ECMAScript 5.1 版的全部功能。 2015 年 6 月，ECMAScript 6 正式发布，并且更名为 ECMAScript 2015，计划以后每年发布一个 ECMAScript 版本。 2016 年 6 月，《ECMAScript 2016 标准》发布。 2017 年 6 月，《ECMAScript 2017 标准》发布，正式引入 async。 浏览器大战浏览器大战无疑是所有的前端开发人员无法忽略的一个部分，因为它的后遗症我们至今还能略窥一二。IE 兼容不知道是多少前端工程师的噩梦。李爵士在创建万维网的同时创建了第一个浏览器 WorldWideWeb ，后来更名为 Nexus，于 1991 年于 NeXTSTEP 平台发布。 1992 年底，陆续出现了其它浏览器。 1993 年出现的浏览器中最具影响力的是 Mosaic，由美国国家超级电脑应用系统（NCSA）开发，并授权多家公司让他们创造自己的产品。Mosaic 的开发者之一马克·安德森于 1994 年成立了 Mosaic Communications Corporation 公司，并开发了 Mosaic Netscape 浏览器，后因为法律问题改名为 Netscape Communications Corporation，也就是我们后来熟知的网景通讯公司，浏览器也改名为 Netscape Navigator，很快该浏览器统领了浏览器市场。 1995 年，微软在 Mosaic 基础上开发了 Internet Explorer，通过 Windows 搭售。IE 开始进入浏览器市场。IE3 于 1996 年 8 月发布，在 CSS1 尚未成为 W3C 推荐标准的时候率先支持了 CSS1，Netscape Navigator 4.0 随之也支持了 CSS1。他们为了超越彼此，给自己的浏览器增加了很多新的功能。一方面促进了互联网的快速发展，另一方面却因为忽视标准，为兼容问题埋下了隐患。标准还在那里，但互联网永远是实用大于理论，开发者面向 IE/Netscape 开发网页。后来我们知道，微软在 IE 里面加的部分不符合标准的特性使得有些网页只能用 IE 打开。这场对决最终在 1998 年底以 IE 胜出落幕。当 IE 一家独大的时候，浏览器创新的脚步就慢了下来。安全问题随之而来。与此同时，失败的 Netscape 开放了源码，该产品使用 Mozilla 的名称，在 2002 年推出 1.0 版。它的衍生产品之一 Firefox 于 2004 年推出 1.0 版，是的，就是我们熟悉的火狐浏览器。体积小、可定制、使用快捷的 Opera 3.5 在 1998 年 11 月发布，加入了浏览器市场。 2008 年，Google 推出了 Google Chrome 浏览器，自此 Internet Explorer 走向衰落。 2013 年，Opera 放弃自有的 Presto 渲染引擎，改用 Chromium 系的 Blink 引擎。 2015 年，微软开始开发 Microsoft Edge 浏览器并逐步放弃 IE。 2020 年，Edge 放弃自有的 EdgeHTML 浏览器引擎，改用 Chromium 系的 Blink 引擎。 2022 年 6 月，Microsoft 永久停用 Internet Explorer。早期的浏览器大战中，不同的浏览器的渲染引擎不同，导致渲染的效果有出入，css hack 应运而生，用于解决不同浏览器上样式展示不一致的问题。而后来的参与者明显更加尊重标准，避免了 web 开发人员面向多个不兼容的平台开发。 万维网的历史大事记 1990 年，李爵士及其团队创建了第一个网络浏览器 WorldWideWeb、第一个网络服务器（后来被称为 CERN httpd）以及描述项目本身的第一个页面。 1991 年 8 月 6 日，万维网首次亮相。 1993 年 4 月 30 日，CERN 宣布万维网对任何人免费开放，不收取任何费用。 1994 年 10 月，W3C 成立，创建者是李爵士。W3C 致力于维护和制定 web 相关的标准，解决不同平台、技术和开发者带来的不兼容问题，保障网络资讯的流通。 1995 年 6 月，Rasmus Lerdorf 为了维护个人网站创建了 PHP Tools (Personal Home Page Tools)，后经过重写又改名为 PHP (Hypertext Preprocessor)。PHP 的发展让 HTML 从纯粹的静态页面，变成了模板引擎。同年，网景推出 JavaScript，让网页可以有逻辑处理功能。 1996 年，W3C 发布 CSS 1.0 标准。同年，微软推出 iframe 标签，实现了异步的局部加载。 1997 年，微软发布的 IE4 中引入了 DHTML (Dynamic HTML, 动态 HTML)，允许通过 HTML、CSS 和脚本语言来动态展示页面。但当时还没有 AJAX 技术，所以只是把网页内容都加载下来之后，根据脚本语言和事件交互来确定是否展示。 1999 年，微软推出用于异步数据传输的 ActiveX，随即各大浏览器厂商模仿实现了 XMLHttpRequest，允许 JavaScript 发送 HTTP 请求，这为后来大行其道的 Ajax 创造了条件。2006 年，XMLHttpRequest 被 W3C 正式纳入标准。 2000 年，KDE 项目重写了浏览器引擎 KHTML，为后来的 WebKit 和 Blink 引擎打下基础。 2001 年，Douglas Crockford 提出了 JSON，用于取代 XML 格式，进行服务器和网页之间的数据交换。JavaScript 原生支持 JSON。 2004 年，Google 公司发布了 Gmail，促成了互联网应用程序（Web Application）这个概念的诞生。同年，Dojo 框架诞生，为不同浏览器提供了同一接口，并为主要功能提供了便利的调用方法。这标志着 JavaScript 编程框架的时代开始来临。同年，各大浏览器厂商组成 WHATWG 小组，致力于加速 HTML 语言的标准化进程。 2005 年，苹果公司在 KHTML 引擎基础上，建立了 WebKit 引擎。同年，Ajax (Asynchronous JavaScript and XML) 正式诞生，Jesse James Garrett 发明了这个词汇。 2006 年，John Resig 发布了 JQuery，使得 JS 操作 DOM 更加方便。同年，Google推出 Google Web Toolkit 项目（缩写为 GWT），提供 Java 编译成 JavaScript 的功能，开创了将其他语言转为 JavaScript 的先河。 2007 年，Webkit 引擎在 iPhone 手机中部署，JavaScript 进军手机。 2009 年，Ryan Dahl 发布了 Node.js，它标志着 JavaScript 可以用于服务器端编程。同年，AngularJS 诞生，后被谷歌收购。 2010 年，NPM(Node 模块管理器)、BackboneJS 和 RequireJS 的诞生标志着 JavaScript 进入模块化开发的时代。 2012 年，单页面应用程序框架（single-page app framework）开始崛起，AngularJS 和 Ember 都发布了 1.0 版本。同年，微软发布 TypeScript 语言，该语言被设计为 JavaScript 的超集。 2013 年，ECMA 正式推出 JSON 的国际标准。同年 5 月，Facebook 发布 UI 框架库 React，引入 JSX 语法，使得 UI 层可以用组件开发。 2014 年，Vue.js 诞生。 2015 年 3 月，Facebook 公司发布了 React Native 项目，将 React 框架移植到了手机端，可以用来开发手机 App。同年 5 月，Angular 框架宣布 2.0 将基于 TypeScript 开发。 参考资料维基百科万维网WWW 的原始提案前端开发 20 年变迁史URL 和 URI 的区别菜鸟笔记 URL 和 URI 的区别HTTP 的历史维基百科 HTTPHTML 的发展历史CSS 二十年发展简史CSS 传奇维基百科浏览器大战浏览器及其内核JavaScript 语言的历史维基百科 Dynamic HTML","categories":[{"name":"计算机","slug":"计算机","permalink":"http://yoursite.com/categories/计算机/"},{"name":"前端","slug":"计算机/前端","permalink":"http://yoursite.com/categories/计算机/前端/"}],"tags":[]},{"title":"发布订阅模式的实现","slug":"发布订阅模式的实现","date":"2021-04-17T15:06:57.000Z","updated":"2022-11-25T06:28:53.837Z","comments":true,"path":"2021/04/17/发布订阅模式的实现/","link":"","permalink":"http://yoursite.com/2021/04/17/发布订阅模式的实现/","excerpt":"","text":"什么叫做“发布-订阅”模式举一个简单的例子，我对物理感兴趣，于是我上微信公众号关注了“中科院物理所”，所以“中科院物理所”每天发文章我都能收到。在这个过程中，我“订阅”了中科院物理所的文章，因此，只要它一“发布”文章，我就能收到。在这之间，还有一个媒介——微信公众号平台。我通过这个平台去订阅事件，物理所通过这个平台来发布事件。发布事件的人，订阅事件的人，加一个两者沟通的中介。这就是一个完整的“发布-订阅”模式。 写一个例子代码123456789101112131415161718192021222324252627282930313233class EventHub &#123; // 事件中心 constructor() &#123; this.list = &#123;&#125;; &#125; publish(eventName) &#123; // 发布 if (!this.list || !this.list.hasOwnProperty(eventName)) &#123; return; &#125; for (let i = 0; i &lt; this.list[eventName].length; i++) &#123; let fn = this.list[eventName][i].fn; let event = this.list[eventName][i].event; fn(event); &#125; &#125; subscribe(eventName, fn) &#123; // 订阅 if (!this.list) &#123; this.list = &#123;&#125;; &#125; if (!this.list.hasOwnProperty(eventName)) &#123; this.list[eventName] = []; &#125; let event = new Event(eventName); this.list[eventName].push(&#123; event: event, fn: fn &#125;); &#125;&#125;const eventhub = new EventHub();eventhub.subscribe(&quot;progress&quot;, (e) =&gt; &#123; // 订阅 progress 事件 console.log(e.type);&#125;);eventhub.subscribe(&quot;progress&quot;, () =&gt; &#123; console.log(&quot;progress 2&quot;);&#125;);eventhub.publish(&quot;progress&quot;); // 发布 progress 事件 从一道面试题说起 通过 new PipeLine() 可以创建一个 pipe 实例，该实例挂载两个方法： on 方法调用 on 方法，可以通过传参来绑定事件名、事件函数，事件函数会默认携带两个参数：ctx、next。其中 ctx 是一个对象，访问 name 可以获取当前的事件名。next 是一个函数，表示执行事件列表中的下一个事件。如果 next 不被调用，则默认不执行下一个事件。 run 方法调用 run 方法，会按照 pipe 的事件绑定顺序，依次执行，直到事件函数中不再调用 next。实现效果如下：123456789101112131415const pipe = new PipeLine();pipe.on(&quot;start&quot;, (ctx, next) =&gt;&#123; console.log(ctx.name); next();&#125;);pipe.on(&quot;progress&quot;, (ctx, next) =&gt;&#123; console.log(ctx.name);&#125;);pipe.on(&quot;end&quot;, (ctx, next) =&gt;&#123; console.log(ctx.name); next();&#125;);pipe.run();// 输出结果：&quot;start&quot; &quot;progress&quot;// 因为 progress 没有执行 next() , 因此后面绑定的 &quot;end&quot; 不执行 拿到题目的第一反应是发布-订阅模式，与前面的例子不同的是： 不区分事件名 默认不继续执行下一个绑定事件 顺着这个思路往下写，应该是先去掉事件名。因此 this.list[eventName].push() 直接变成了 this.list.push().这样不论你绑定的是什么事件，都会直接运行，run 方法也不需要传递参数 eventName.再有就是在 next 方法没有执行的时候阻止后续绑定事件的执行。也就是把后续执行函数放到 next 方法中传给前一个绑定事件。原先的代码是这样的12345for (let i = 0; i &lt; this.list.length; i++) &#123; let fn = this.list[i].fn; let ctx = this.list[i].ctx; fn(ctx, next);&#125; 把 fn(ctx, next) 提取出来，放到 fn 的第二个参数中，作为 next 函数传递给这个事件，通过递归就可以实现前一个事件调用 next 之后执行下一个事件。12345678910let a = (i) =&gt; &#123; if (i &lt; this.list.length) &#123; let fn = this.list[i].fn; let ctx = this.list[i].ctx; fn(ctx, () =&gt; &#123; a(++i); &#125;); &#125;&#125;;a(0); 完整代码 如果，我想要默认按顺序执行所有的绑定事件，但是一旦执行了 ctx.stop() 就终止后面的绑定事件呢？把上面的代码稍稍改一改，让 ctx.stop 终止循环，是不是就可以了？12345678910let a = (i) =&gt; &#123; if (i &lt; this.list.length) &#123; let fn = this.list[i].fn; let ctx = this.list[i].ctx; ctx.stop = ()=&gt;&#123;i=this.list.length&#125; fn(ctx); a(++i) &#125;&#125;;a(0); 看到这里，有没有想到什么？ addEventListener 做了什么不知道你们有没有了解过 DOM 的 addEventListener 和 click事件。添加一个事件监听，执行一个点击事件。下面是一个简单的 click 事件。源码123456789101112let btn = document.querySelector(&quot;#btn&quot;)btn.addEventListener(&quot;click&quot;, (e)=&gt;&#123; console.log(e.type); // 输出 &quot;click&quot;&#125;)btn.addEventListener(&quot;click&quot;, (e)=&gt;&#123; console.log(&quot;2&quot;) e.stopImmediatePropagation(); // 阻止后面绑定的监听事件&#125;)btn.addEventListener(&quot;click&quot;, (e)=&gt;&#123; console.log(&quot;3&quot;)&#125;)btn.click() // 手动执行 click 事件 和上面的面试题是不是有点像？我们把上面面试题代码稍稍改动一下，把 on 变成 addEventListener , 同时把 run 变成 click, 把 ctx 变成 event, 把 stop() 变成 stopImmediatePropagation().像这样123456789101112const pipe = new PipeLine();pipe.addEventListener(&quot;start&quot;, (e) =&gt; &#123; console.log(e.type);&#125;);pipe.addEventListener(&quot;progress&quot;, (e) =&gt; &#123; console.log(e.type); e.stopImmediatePropagation()&#125;);pipe.addEventListener(&quot;end&quot;, (e) =&gt; &#123; console.log(e.type);&#125;);pipe.click(); 现在是不是更像一点了？源码addEventListener 实际上是添加了一个事件监听，在监听这个事件被触发之后，就会执行回调函数。a.addEventListener(&quot;click&quot;, fn) a 订阅了 click 事件，一旦这个事件被触发，就调用函数 fn 。a.click() 发布了 click 事件，通知所有订阅了 click 事件的人，可以执行你的操作了。 以上，发布-订阅模式和实际应用场景。","categories":[{"name":"计算机","slug":"计算机","permalink":"http://yoursite.com/categories/计算机/"},{"name":"前端","slug":"计算机/前端","permalink":"http://yoursite.com/categories/计算机/前端/"}],"tags":[{"name":"onClick","slug":"onClick","permalink":"http://yoursite.com/tags/onClick/"},{"name":"发布-订阅模式","slug":"发布-订阅模式","permalink":"http://yoursite.com/tags/发布-订阅模式/"}]},{"title":"react获取元素","slug":"react获取元素","date":"2021-04-05T05:06:37.000Z","updated":"2022-11-25T06:28:53.837Z","comments":true,"path":"2021/04/05/react获取元素/","link":"","permalink":"http://yoursite.com/2021/04/05/react获取元素/","excerpt":"","text":"你真的要获取元素吗正常情况下我们并不需要获取元素，如果需要修改某个组件，一般情况下是通过父组件传递的 props 或者自己本身的 state 来重新渲染。但是如果要获取元素， react 同样提供了一些方法。 使用 ref 获取元素class 组件内部 创建 ref this.myRef = React.createRef() 绑定 ref &lt;div ref={this.myRef}&gt;&lt;/div&gt; 获取元素 const ele = this.myRef.current12345678910111213141516171819class CBoxInner extends React.Component &#123; constructor(props) &#123; super(props); this.myRef = React.createRef(); // 创建 ref this.handleClick = ()=&gt;&#123; console.log(this.myRef.current) // 打印出 DOM 元素 &#125; &#125; render() &#123; return ( &lt;div&gt; &lt;div ref=&#123;this.myRef&#125;&gt;Box1 div&lt;/div&gt; // ref 绑定 &lt;button onClick=&#123;this.handleClick&#125;&gt; console log Box1 &lt;/button&gt; &lt;/div&gt; ); &#125;&#125; class 组件外部暴力获取将 ref 绑定在你引用的 class 组件上，不同的是此时的 ref.current 是组件的实例。如果你需要在父组件获取子组件的某个元素，将父组件的 ref 绑定到子组件上，然后通过父组件的 ref 获取子组件的 ref，从而拿到子组件的元素。this.myRef.current.xxxRef.current 1&lt;CBoxInner ref=&#123;this.myRef&#125; /&gt; 通过属性传递相当于 function 组件的 refs 转发（forwardRef）。 在父组件创建 ref this.cBox = React.createRef() 自定义一个属性（x），通过这个属性给子组件传递 ref 。&lt;CBoxInner x={this.cBox} /&gt; 在子组件中给这个 ref 赋值。&lt;div ref={this.props.x} /&gt; 此时你在父组件中直接使用 this.cBox.current 获取的就是子组件的元素。 借用高阶组件的思想高阶组件指的是一个函数，接收一个组件，返回一个新的组件。借用这个函数我们可以创建组件。上面我们知道，借用属性传递可以传递 ref，但是不能直接传递名称为 ref 的属性。所以我们在中间封一层函数组件。123456789class HOCBoxInner extends React.Component &#123; render() &#123; const &#123; forwardRef &#125; = this.props; return &lt;div ref=&#123;forwardRef&#125; /&gt;; &#125;&#125;const HOCBox1 = React.forwardRef((props, ref) =&gt; &#123; return &lt;HOCBoxInner &#123;...props&#125; forwardRef=&#123;ref&#125; /&gt;; &#125;); 此时我们拿到的 HOCBox1 就可以直接传递 ref。&lt;HOCBox1 ref={this.ref} /&gt;因为这样子同时生成了两个组件，一个 HOCBoxInner 一个 HOCBox1.想一想，高阶组件是传递一个组件，返回一个新的组件。如果我们不需要复用的话，那么传递一个组件这个步骤就可以省去了。直接在函数内部创建一个 class 组件。如果你甚至不想暴露函数的话，让它立即执行。1234567891011const HOCBox = (function createHOCBox() &#123; class HOCBoxInner extends React.Component &#123; render() &#123; const &#123; forwardRef &#125; = this.props; return &lt;div ref=&#123;forwardRef&#125; /&gt;; &#125; &#125; return React.forwardRef((props, ref) =&gt; &#123; return &lt;HOCBoxInner &#123;...props&#125; forwardRef=&#123;ref&#125; /&gt;; &#125;);&#125;()) 这样我们拿到的 HOCBox 就是一个可以传 ref 的组件了。 function 组件内部 创建 ref const myRef = useRef(); 绑定 ref &lt;div ref={myRef}&gt;&lt;/div&gt; 获取元素 const ele = this.myRef.current123456789101112function FBoxInner() &#123; const myRef = useRef(); const handleClick = () =&gt; &#123; console.log(myRef.current); &#125;; return ( &lt;div&gt; &lt;div ref=&#123;myRef&#125;&gt;function div&lt;/div&gt; &lt;button onClick=&#123;handleClick&#125;&gt;console log function&lt;/button&gt; &lt;/div&gt; );&#125; function 组件外部class 组件外部使用 ref 获取的是 class 组件的实例，而 function 组件没有实例，所以无法使用 ref={myRef} 来绑定获取。function 组件使用 forwardRef 来实现。function 组件声明一般是 function Xxx(props){} , 使用 forwardRef 的话，是这样 const Xxx = React.forwardRef((props, ref)=&gt;{}). 我们可以直接在参数中获取父组件传递过来的 ref 。 父组件创建 ref 。this.mref = React.createRef() 父组件给子组件传递 ref &lt;Child ref={this.mref} /&gt; 子组件给 ref 赋值 &lt;div ref={ref} /&gt; 使用回调函数获取使用回调函数获取 ref 的话，function 组件和 class 组件使用方法一致。12345678910111213function CBFBoxInner() &#123; let myRef = null; const setRef = (el) =&gt; (myRef = el); const handleClick = () =&gt; &#123; console.log(myRef); &#125;; return ( &lt;div&gt; &lt;div ref=&#123;setRef&#125;&gt;callback function div&lt;/div&gt; &lt;button onClick=&#123;handleClick&#125;&gt;console log callback function&lt;/button&gt; &lt;/div&gt; );&#125; 需要注意的是此时获取的 myRef 就是元素本身，不需要 myRef.current . findDOMNode() 同样可以获取元素，但是不推荐使用，且严格模式下该方法已经弃用。ref 获取元素 Demo 受控组件 VS 非受控组件在一个表单中，受控组件指的是表单元素的值完全由 state 控制，非受控组件指的是表单元素的值由它本身控制。比如一个 input 框，我输入一个 “xxx” 。受控组件是我给它绑定一个 onChange 事件，一旦它发生了改变，我就修改 state 的值，而因为我修改了 state 的值，所以这个 input 的 value 就改变了。非受控组件是我给它绑定一个 ref ，在我需要的时候直接通过获取 DOM 元素的 value 来获取它的值。&lt;input type=&quot;file&quot; /&gt; 始终是一个非受控组件。","categories":[{"name":"计算机","slug":"计算机","permalink":"http://yoursite.com/categories/计算机/"},{"name":"前端","slug":"计算机/前端","permalink":"http://yoursite.com/categories/计算机/前端/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"},{"name":"ref","slug":"ref","permalink":"http://yoursite.com/tags/ref/"}]},{"title":"react入门使用","slug":"react入门使用","date":"2021-04-03T08:17:19.000Z","updated":"2022-11-25T06:28:53.836Z","comments":true,"path":"2021/04/03/react入门使用/","link":"","permalink":"http://yoursite.com/2021/04/03/react入门使用/","excerpt":"","text":"react 的要点在于用 js 仿 html，保留了前端开发习惯的同时几乎把 html 彻底干掉了。在写 js 语句的时候，用的就是 js 语法。而在写 “html” 的时候，用的是 react 提供的语法。这篇文章介绍了在 react 中如何使用 if/else 条件判断，for 循环，内联样式。 if-elsedemo &amp;&amp; return flag &amp;&amp; &lt;div&gt;hello&lt;/div&gt; 。 如果 flag 为真就返回 &lt;div&gt;hello&lt;/div&gt;, 否则返回 false。 冒号表达式 return flag ? &lt;div&gt;hello&lt;/div&gt;: &lt;div&gt;hi&lt;/div&gt; 。 如果 flag 为真就返回 &lt;div&gt;hello&lt;/div&gt; 否则返回 &lt;div&gt;hi&lt;/div&gt;。 直接使用 if-else1234567let content = &quot;&quot;if (flag) &#123; content = &lt;div&gt;hello&lt;/div&gt;&#125; else &#123; content = &lt;div&gt;hi&lt;/div&gt;&#125;return content fordemo 创建一个数组，然后将 list 中的每一项裹上 div push 进去，再将这个数组放到页面上。 1234567891011121314151617// const infoList = [&quot;item1&quot;, &quot;item2&quot;, &quot;item3&quot;];const infoList = [&quot;item1&quot;, &quot;item2&quot;, &quot;item3&quot;];function App() &#123; const content = []; for (let item of infoList) &#123; content.push(&lt;div&gt;&#123;item&#125;&lt;/div&gt;); &#125; return &lt;div className=&quot;App&quot;&gt;&#123;content&#125;&lt;/div&gt;;&#125;// const objList = &#123;&quot;0&quot;: &quot;a&quot;, &quot;1&quot;: &quot;b&quot;, &quot;2&quot;: &quot;c&quot;&#125;const content = []for (let key in objList) &#123; let item = &lt;div&gt;&#123;key&#125;: &#123;objList[key]&#125;&lt;/div&gt; content.push(item)&#125;return &lt;&gt;&#123;content&#125;&lt;/&gt; 使用 Array.map 实现 12const content = infoList.map((value) =&gt; &lt;div&gt; &#123;value&#125; &lt;/div&gt;);return &lt;&gt;&#123;content&#125;&lt;/&gt;; 当然，你也可以把它嵌入到下面 1234567return ( &lt;&gt; &#123;infoList.map((value, index) =&gt; ( &lt;div&gt; &#123;value&#125; &lt;/div&gt; ))&#125; &lt;/&gt; ); 内联样式123function Box() &#123; return &lt;div style=&#123;&#123;border: &quot;1px solid red&quot;&#125;&#125;&gt;1111&lt;/div&gt;;&#125; 这段代码翻译过来是1234567function Box() &#123; return React.createElement(&quot;div&quot;, &#123; style: &#123; border: &quot;1px solid red&quot; &#125; &#125;, &quot;1111&quot;);&#125; 这样我们就比较好理解语法了。jsx 中 &lt;div&gt; 内如果我们没有加 {} 会默认认为是字符串，而加了大括号的话会以变量来编译。在 style 属性里添加 border 为 1px 。外面的大括号表明这是一个变量，里面的大括号表明这个变量是一个对象。因为它实际是一个对象，所以如果有多个样式的话应该使用逗号分隔 border: &quot;1px&quot;, borderRadius: &quot;5px&quot;。因为 js 不支持 - 作为变量名，所以原本的 border-radius 变成了 borderRadius.注意样式值需要用引号包裹，因为它应该是一个字符串。 总的来说，用 js 的思想去考虑应该要怎么写。","categories":[{"name":"计算机","slug":"计算机","permalink":"http://yoursite.com/categories/计算机/"},{"name":"前端","slug":"计算机/前端","permalink":"http://yoursite.com/categories/计算机/前端/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"获取表单数据","slug":"获取表单数据","date":"2021-04-03T02:57:10.000Z","updated":"2022-11-25T06:28:53.838Z","comments":true,"path":"2021/04/03/获取表单数据/","link":"","permalink":"http://yoursite.com/2021/04/03/获取表单数据/","excerpt":"","text":"使用 js 获取表单数据使用 js 提供的 FormData 来获取表单数据。 获取表单 const form = document.querySelector(&quot;#myForm&quot;) 创建一个 FormData 对象 let formData = new FormData(form) for 循环遍历 FormData.entires() 获取所有的 key、value for(let [key, value] of formData.entires()){} . formData.entires() 每一项分别是 item[0] 和 item[1], 给它们赋值为 key 和 value。1234567891011function getFormDataWithJs() &#123; const form = document.querySelector(&quot;form&quot;); let formData = new FormData(form); let data = [] // 这里不能用 hash 存否则多选框的多个值会被覆盖掉 for (let [key, value] of formData.entries()) &#123; let item=&#123;&#125;; item[key] = value data.push(item) &#125; return data&#125; 使用 jquery 获取表单数据1234function getFormDataWithJquery() &#123; // $(&quot;#myForm&quot;).serialize() get a string return $(&quot;#myForm&quot;).serializeArray()&#125; 获取表单信息的 demo","categories":[{"name":"计算机","slug":"计算机","permalink":"http://yoursite.com/categories/计算机/"},{"name":"前端","slug":"计算机/前端","permalink":"http://yoursite.com/categories/计算机/前端/"}],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"Hooks使用指南","slug":"Hooks使用指南","date":"2021-04-02T04:08:51.000Z","updated":"2022-11-25T06:28:53.835Z","comments":true,"path":"2021/04/02/Hooks使用指南/","link":"","permalink":"http://yoursite.com/2021/04/02/Hooks使用指南/","excerpt":"","text":"16.8 新增特性作用： react 组件分为函数组件和类组件，Hooks 可以让我们在函数组件中使用一些类属性的东西。 使用自定义 hook 可以复用状态逻辑 使用规则： 只能在函数最外层调用 Hook，不要在循环、条件判断或者子函数中调用。确保每次都以同样的顺序调用。 只能在 React 的函数组件和自定义 Hook 中调用 Hook 把 class 组件改造成 function 组件class 组件和 function 组件有两大区别，一是有自己的 state ，二是有自己的生命周期。而 Hooks 给我们提供了一些 API，可以让我们在 function 中使用 state 和生命周期。 在 function 组件中使用 stateDemo在函数组件中使用 useState 。12345import &#123;useState&#125; from &quot;react&quot;function Div() &#123; const [a, setA] = useState(0) return &lt;div&gt;&#123;a&#125;&lt;/div&gt;&#125; 这段代码在 Div 里面声明了一个变量 a 和一个 setA 的函数，如果我需要将 a 的值改为 1 ，那么可以直接 setA(1).其中声明 state 的代码 const [a, setA] = useState(0) 相当于123const xxx = useState(0) // 返回了一个有两个元素的数组const a = xxx[0] const setA = xxx[1] 如果我们需要多个元素的话，可以使用多次声明的方法，也可以借助对象来实现。123const [age, setAge] = useState(0)const [name, setName] = useState(&quot;Cindy&quot;)// name 获取 name 值 或者12345const [info, setInfo] = useState(&#123; age: 0, name: &quot;Cindy&quot;&#125;)// info.name 获取 name 值 需要注意的是在 class 组件中，如果我们使用 this.setState({name: &quot;Wency&quot;}) 不会覆盖掉 age 属性，但是在这里会直接覆盖掉。因此我们如果需要覆盖而不是替换，则需要手动重新赋值。这里使用 ES6 的解构可以快速完成：1234setInfo(&#123; ...info, // 把 info 这个对象里的每一项都列出来 name: &quot;Wency&quot;&#125;) 在 function 组件中使用 lifecycleuseEffect 几乎可以满足我们的需求。使用 useEffect 模拟生命周期 demouseEffect 在组件每次渲染的时候都会调用，使用方法如下。123456function MyComponent() &#123; useEffect(function()&#123; console.log(&quot;我被调用了&quot;) &#125;) return &lt;div&gt;111&lt;/div&gt;&#125; 在 useEffect 内部返回一个函数的话，这个函数会在下一次更新的时候先运行，然后再运行 useEffect 内部的语句。下面这段代码在函数组件第一次被挂到页面的时候会在控制台输出1。以后一旦组件更新了，会先执行 console.log(0) 再执行 console.log(1)1234567function MyComponent() &#123; useEffect(function()&#123; console.log(1) return ()=&gt;&#123;console.log(0)&#125; &#125;) return &lt;div&gt;111&lt;/div&gt;&#125; 如果需要只在组件被卸载的时候执行该语句，那么需要给 useEffect 传入第二个参数 []。useEffect 的第二个参数指定了哪些数据发生变化的时候执行这个 effect ，比如我想在 name 修改的时候执行 console.log(&quot;I changed my name&quot;) 而 age 发生修改的时候什么都不做，那么只需要传入 [name] 即可。123useEffect(()=&gt;&#123; console.log(&quot;I changed my name&quot;)&#125;, [name]) 需要注意的是如果你的函数里面依赖了某些变量，那么这个变量也需要放在数组里。有一种情况需要特别注意：123useEffect(()=&gt;&#123; setAge(age=&gt;(age+1)) //setAge(age + 1) is wrong&#125;, [name]) 绝对不要在 setAge 的同时在数组里面添加 age，不然会一直循环调用。 总结： useEffect(()=&gt;{...}) 在每次渲染之后都会调用 useEffect(()=&gt;{...}, [count]) 在 count 改变的时候调用 useEffect(()=&gt;{...}, []) 仅在组件挂载和卸载时执行 useEffect(()=&gt;(()=&gt;{...}), []) 仅在组件卸载时执行 在 class 组件中，如果你需要执行一个 subscribe，那么需要在 componentDidMount 里边 subscribe 一下，然后再在 componentWillUnmount 里边 unsubscribe而在使用 useEffect 的情况下，你需要在函数里进行 subscribe, 然后再 return 一个函数执行 unsubscribe。形如123456useEffect(()=&gt;&#123; xxx.subscribe() return ()=&gt;&#123; xxx.unsubscribe() &#125;&#125;) 好处是我们可以根据代码的用途来分离它们。并且每次组件更新的时候会自动 unsubscribe 前面的，然后重新 subscribe。（先清除上一个 effect，再执行这个 effect。）如果是在 class 组件中，则需要通过 componentDidUpdate 来做这件事。 抛开 lifecycle 不谈，所有有副作用的函数或表达式都应该在 useEffect 里面执行。副作用（Side Effect）：函数或者表达式的行为依赖于外部世界 函数或者表达式修改了它的 scope 之外的状态 函数或表达式除了返回语句外还与外部世界或者他所调用的函数有明显的交互行为作用：产生了影响副作用：可能产生意料之外的影响比如，我要在一个函数里修改 DOM 元素，正常是没有问题的。但是我有可能找不到这个元素，一旦我找不到这个元素，那么就会有意料之外的报错。这就是副作用。再比如，我在函数内部调用了 console.log(111) ,正常调用这个函数应该会在控制台输出 111 。 但是这个 console.log 函数是别处来的，可能会被篡改，比如 console.log = ()=&gt;{alert(111)} 。此时我的函数执行结果就会是 alert 一个 111。这同样是意料之外的结果。所以一个没有副作用的函数，应该是函数本身的行为不依赖外部世界的函数。数据获取、设置订阅以及手动修改 DOM 都属于副作用。 useContext 获取 context 的值在函数组件中使用 const theme = useContext(ThemeContext) 来获取 context 的值。在类组件中使用const theme = this.context 来获取 context 的值，需要在 class 外面使用 MyClass.contextType = SecretContext 进行 context 的绑定。 自定义一个 Hook使用自定义 Hook 模拟 componentDidUpdate 函数名使用 use 开头，比如 function useDidUpdate(){} 自定义 Hook 里面可以使用 react 内置的 Hooks 用来提取可复用的状态逻辑。比如我如果在很多组件中都要用到 componentDidUpdate, 我不想把这个逻辑写很多次，所以就提取出来，封装成一个函数，在各个地方调用。或者我需要写入 localStorage, 封装一个写入的方法，只使用这个方法来调用。","categories":[{"name":"计算机","slug":"计算机","permalink":"http://yoursite.com/categories/计算机/"},{"name":"前端","slug":"计算机/前端","permalink":"http://yoursite.com/categories/计算机/前端/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"},{"name":"Hooks","slug":"Hooks","permalink":"http://yoursite.com/tags/Hooks/"}]},{"title":"react生命周期","slug":"react生命周期","date":"2021-03-30T13:54:20.000Z","updated":"2022-11-25T06:28:53.836Z","comments":true,"path":"2021/03/30/react生命周期/","link":"","permalink":"http://yoursite.com/2021/03/30/react生命周期/","excerpt":"","text":"JS 的生命周期有哪些暂且抛开 react ，单说生命周期。一个元素，从出生到死亡的全过程。 创建元素 填充内容 挂载到页面 更新内容 销毁元素演示 Demo react 生命周期有哪些官网文档组件的生命周期 挂载相关constructor()static getDerivedStateFromProps() render()*componentDidMount()componentWillMount() 即将过时 更新相关static getDerivedStateFromProps()shouldComponentUpdate()render()getSnapshotBeforeUpdate() componentDidUpdate()componentWillUpdate() 即将过时componentWillReceiveProps() 即将过时 卸载相关*componentWillUnmount() 错误处理（抛出错误的时候会调用的方法）static getDerivedStateFromError()componentDidCatch() 生命周期示例生命周期图示，点击 Show less common lifecycles 可看见所有的生命周期。正常情况下当你创建了一个组件，会先执行 constructor 方法构建组件，然后是 getDerivedStateFromProps 来从 props 中获取新的 state 值（仅在某些特殊时候需要用），然后是 render 进行组件的渲染，最后挂载到页面之后会执行 componentDidMount 。如果你需要更新一个页面，改变自己的 state 之后，会先执行 getDerivedStateFromProps ，然后执行 shouldComponentUpdate ，如果这个函数返回的是 false ，那么就不继续更新页面（但是此时的 state 值已经改了）。如果确定要继续更新页面的话，会继续执行 render 进行渲染。getSnapshotBeforeUpdate 在渲染出来的新东西挂载到页面之前获取之前的状态，props 和 state，这个函数的返回值会作为 componentDidUpdate 的第三个参数。 componentDidUpdate 在组件更新之后执行。如果子组件出现了错误，那么会先执行父组件的 getDerivedStateFromError 从错误信息获取新的 state 值，然后卸载子组件，在卸载子组件之前执行子组件的 componentWillUnmount 方法。然后执行父组件的 componentDidCatch 捕获错误信息写入日志。如果子组件是正常卸载的话，只会执行子组件的 componentWillUnmount 。 生命周期方法使用constructor()常用场景： init state 事件处理函数（注意使用箭头函数或者 bind 来避免 this 潜在的问题） render() 返回一个 react 元素 &lt;div&gt;&lt;h1&gt;Hi&lt;/h1&gt;&lt;/div&gt; 返回多个 react 元素 12345&lt;React.Fragment&gt; &lt;h1&gt;Hi&lt;/h1&gt; &lt;h1&gt;Hello&lt;/h1&gt; &lt;h1&gt;Valemagalas&lt;/h1&gt; &lt;/React.Fragment&gt; 或者省去 React.Fragment , 形如 12345&lt;&gt; &lt;h1&gt;Hi&lt;/h1&gt; &lt;h1&gt;Hello&lt;/h1&gt; &lt;h1&gt;Valemagalas&lt;/h1&gt;&lt;/&gt; 返回一个挂载在某个元素上的元素，常用于创建对话框。 1234return ReactDOM.createPortal( this.props.children, domNode); 假如这是一个对话框，组件名为 Dialog , 我们可以把 domNode 设置为根元素，然后在这里面写对话框的具体内容 &lt;Dialog&gt;...&lt;/Dialog&gt; 返回 Boolean ，常用于 return flag &amp;&amp; &lt;Child /&gt; ，flag 为 boolean ，如果 flag 为 true ，则渲染 Child 组件，否则什么都不渲染。 js 有 6 种原始数据类型和三种复杂数据类型: Undefined(undefined), Boolean(false), Number(123), String(“”), BigInt(BigInt(“9”)/9n), Symbol(Symbol()), Null(null), Object({}), Function(()=&gt;{})render 不能返回 undefined, Object, 可以返回 Boolean, Number, String, BigInt, Symbol, Null, Function。其中返回 String 或者 Number，比如 hello 。它会把它直接渲染到页面。BigInt 和 Symbol, Boolean 不会报错。Function 会给出一个警告。允许 return null 但是不允许 return undefined componentDidMount()已经 render ，挂到了 DOM 树上，但是还没有显示到屏幕。常用场景： 向后台请求数据 设置 subscription（添加事件订阅），注意要在 componentWillUnmount() 里边 unsubsribe。 componentDidUpdate(prevProps, prevState, snapshot)在触发更新之后调用，初始化的时候不会调用。如果组件实现了 getSnapshotBeforeUpdate() 生命周期，它的返回值就是这个的第三个参数。如果 shouldComponentUpdate() 的返回值为 false，则不会调用 componentDidUpdate() componentWillUnmount()组件销毁之前调用 shouldComponentUpdate()首次渲染或者使用 forceUpdate() 时不调用此方法，返回 false 时会阻止组件更新。 forceUpdate() &amp; setState()这两个是我们主动调用，其它都是 react 自动调用。更新一般发生在 state 或者 props 发生改变的时候，但如果你使用了其他数据，可以用 forceUpdate 来强制更新。forceUpdate 不会触发 shouldComponentUpdate 。123456789101112131415161718class Box1 extends React.Component &#123; constructor() &#123; super(); this.name = 2333 &#125; handleClick = ()=&gt;&#123; this.name = Math.random() this.forceUpdate() &#125; render() &#123; console.log(&quot;render&quot;); return ( &lt;div&gt; hello, &#123;this.name&#125; &lt;button onClick=&#123;this.handleClick&#125;&gt; Click me &lt;/button&gt; &lt;/div&gt; ) &#125; &#125; static getDerivedStateFromProps(props, state)会在调用 render 之前调用，返回一个对象来更新 state，如果返回 null 则不更新任何内容。使用方法每次渲染前都会触发这个方法，不论是 props 更新了还是 state 更新了。 getSnapshotBeforeUpdate(prevProps, prevState)在 update 之前获取一些信息，返回值会传给 componentDidUpdate() static getDerivedStateFromError(error) &amp; componentDidCatch(error, errorInfo)Error boundaries demo错误边界，捕获子组件的错误。如果子组件发生了错误，那么显示降级 UI 。这两个用来做这件事情。getDerivedStateFromError 将抛出的错误作为参数，返回新的 state 值。在渲染阶段调用，不允许有副作用（不确定的输出结果）。可以用来设置 state 值，从而渲染降级 UI。componentDidCatch 在后代组件抛出错误时调用，允许有副作用。可以用来写 error log。 使用总结 constructor: 数据初始化（state 初始化）、事件监听。其中数据更新会放在点击事件里边，需要注意的是 setState 会触发组件的更新，所以不要在组件更新的钩子里写 setState 。 componentDidMount: 数据请求、事件订阅 shouldComponentUpdate: 手动阻止更新 遇到什么操作该放到哪里的问题时，反向想一想它不能放在哪。比如说 ajax 请求，如果我需要获取数据，那么按说挂载的几个生命周期都可以，constructor, getDerivedStateFromProps, render, componentDidMount, 但是官网说 constructor 中要避免引入副作用， getDerivedStateFromProps 主要用来从 props 获取 state， render 在每次更新的时候都会调用，所以只能放在 componentDidMount 里边了。","categories":[{"name":"计算机","slug":"计算机","permalink":"http://yoursite.com/categories/计算机/"},{"name":"前端","slug":"计算机/前端","permalink":"http://yoursite.com/categories/计算机/前端/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"},{"name":"生命周期","slug":"生命周期","permalink":"http://yoursite.com/tags/生命周期/"}]},{"title":"ReactRouter使用指南","slug":"ReactRouter使用指南","date":"2021-03-29T10:32:56.000Z","updated":"2022-11-25T06:28:53.836Z","comments":true,"path":"2021/03/29/ReactRouter使用指南/","link":"","permalink":"http://yoursite.com/2021/03/29/ReactRouter使用指南/","excerpt":"","text":"router 是路由，在互联网上，把信息从源地址传输到目的地址的活动。React Router 是一个基于 React 的路由库，帮助我们在解析路由的同时保持页面与 URL 之间的同步。 React Router 的使用一个简单的 tab 页 引入 react-router-dom 库，因为是在浏览器上的应用，不是 native ，所以引入的是 -dom 库 在代码中添加路由 123456789101112131415import &#123; BrowserRouter as Router, Link, Switch, Route &#125; from &quot;react-router-dom&quot;;&lt;Router&gt; &lt;div&gt; &lt;nav&gt; &lt;Link to=&quot;/&quot;&gt;Home&lt;/Link&gt; &lt;Link to=&quot;/about&quot;&gt;About&lt;/Link&gt; &lt;Link to=&quot;/users&quot;&gt;Users&lt;/Link&gt; &lt;/nav&gt; &lt;Switch&gt; &lt;Route path=&quot;/about&quot;&gt;about&lt;/Route&gt; &lt;Route path=&quot;/users&quot;&gt;users&lt;/Route&gt; &lt;Route path=&quot;/&quot;&gt;home&lt;/Route&gt; &lt;/Switch&gt; &lt;/div&gt;&lt;/Router&gt; 实现的效果是点击 nav 中的按钮之后下面的 switch 中会自动显示相应的区域，并且 URL 也会自动添加相应的后缀。而且在修改了 URL 之后，switch 中也会自动变化。 这就是 React Router 帮我们实现的。 自己实现 React Router 效果Demo 源码 创建一个组件，有 nav 区域和 content 区域。 添加 this.state , 然后给 nav 里面的元素添加点击事件来修改 state 的值。 给 content 区域添加条件渲染，至此已经完成了一个 tab 切换效果。 12345678910111213141516171819render() &#123; let button = &quot;&quot;; switch (this.state.display) &#123; case &quot;users&quot;: button = &lt;div&gt;users&lt;/div&gt;; break; case &quot;about&quot;: button = &lt;div&gt;about&lt;/div&gt;; break; default: button = &lt;div&gt;home&lt;/div&gt;; &#125; return ( &lt;div className=&quot;App&quot;&gt; ... &lt;div className=&quot;content&quot;&gt;&#123;button&#125;&lt;/div&gt; &lt;/div&gt; );&#125; 现在，在切换的时候修改 url ，window.location.hash = &quot;about&quot; 通过 window.location.hash 来初始化 this.state.display 的值，从而实现 content 根据 url 的不同而修改。 这里使用 window.location.hash 来修改 url ，实际上修改路由还可以用 window.location.pathname 和 window.history.pushState() ,要注意他们的区别： window.location.hash = the best way, 不会刷新页面。 12window.location.hash = &quot;home&quot;console.log(window.location.hash) // &quot;#home&quot; window.location.pathname =，修改 pathname 的话，相当于改了路径，浏览器会以为你要跳转页面，于是自动刷新。 12window.location.pathname = &quot;home&quot;console.log(window.location.pathname) // &quot;/home&quot; window.history.pushState(), 同样不刷新页面，但是需要后端将 default 路径都指向首页，不然可能会报这个页面不存在。 12window.history.pushState(null, &quot;&quot;, &quot;home&quot;)console.log(window.location.pathname) // &quot;/home&quot; 以上是不使用 React Router 实现 tab 切换的全过程，React Router 帮我们简化了这个过程。","categories":[{"name":"计算机","slug":"计算机","permalink":"http://yoursite.com/categories/计算机/"},{"name":"前端","slug":"计算机/前端","permalink":"http://yoursite.com/categories/计算机/前端/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"},{"name":"react-router","slug":"react-router","permalink":"http://yoursite.com/tags/react-router/"}]},{"title":"Context使用指南","slug":"Context使用指南","date":"2021-03-29T08:41:06.000Z","updated":"2022-11-25T06:28:53.835Z","comments":true,"path":"2021/03/29/Context使用指南/","link":"","permalink":"http://yoursite.com/2021/03/29/Context使用指南/","excerpt":"","text":"Context 作用Context 用来共享全局数据，避免了使用 props 层层传递。在很多个组件都需要用到同一个变量的时候，可以使用 Context 来设置一个局部的全局变量（只在这一块能用，并且在这一块它是全局变量）。当前认证的用户、主题、首选语言等都可以通过 Context 来传递。 Context 简单使用demoContext 是 react 提供的，所以在 react 应用中不需要引入额外的包。使用步骤： 创建并导出一个 context (注意 import 不要引入错了) 1234import React from &quot;react&quot;;export const SecretContext = React.createContext(&#123; secret: &quot;初始化&quot;&#125;); Provider 提供数据 12345import &#123; SecretContext &#125; from &quot;./context.js&quot;;&lt;SecretContext.Provider value=&#123;&#123; secret: &quot;this is secret&quot; &#125;&#125;&gt; &lt;App /&gt; &lt;App2 /&gt;&lt;/SecretContext.Provider&gt; Provider 中 value 提供的值会在后面子组件中读取值的时候读取到。 这里 value 传的值是一个对象 {secret: &quot;this is secret&quot;}，对象里边可以包含修改这个变量的方法等。 Consumer 获取数据 1234import &#123; SecretContext &#125; from &quot;./context.js&quot;;&lt;SecretContext.Consumer&gt; &#123;(&#123; secret &#125;) =&gt; &lt;div&gt;我知道秘密: &#123;secret&#125;&lt;/div&gt;&#125;&lt;/SecretContext.Consumer&gt; Consumer 获取数据的时候，会从自己往上找，找到了这个 Context 的 Provider 的时候就读取它的值。如果没有 Provider 的话就读取第一步创建 Context 时候的初始值。 Consumer 里面是一个函数，函数传入的值是 Provider 提供的值，return 一个 div。 这个函数展开应该是 1234(value) =&gt; &#123; secret = value.secret // &#123;secret&#125; = value return &lt;div&gt;我知道秘密: &#123;secret&#125;&lt;/div&gt;&#125; 除了上面的 Consumer ，对于 class 组件，使用 contextType 也可以获取 context 的值。1234567class MyClass extends React.Component &#123; render() &#123; let &#123;secret&#125; = this.context; return (&lt;div&gt;我知道秘密: &#123;secret&#125;&lt;/div&gt;) &#125;&#125;MyClass.contextType = SecretContext; 对于函数组件，使用 useContext 可以获取 context 的值1234function MyComponent() &#123; let &#123;secret&#125; = useContext(SecretContext) return (&lt;div&gt;我知道秘密: &#123;secret&#125;&lt;/div&gt;)&#125; 修改 context 的值demo我们在父组件中通过 context 传递了一个变量给子组件，如果想要在子组件中修改这个变量，那么可以直接通过 props 给子组件传递一个修改变量的函数，子组件直接调用这个函数即可。但如果层级太深，或者这个函数在很多地方都有用到，显然这个代码就不那么美观了。我们可以直接将修改变量的函数放在 context 里边，然后在需要的组件中获取这个函数。所以，使用 context 传递全局变量，并且这个变量需要修改的话，可以采用以上两种方法。下面分别来介绍一下使用细节。 使用 props 给子组件传递函数修改这个方法可以单纯的看做是父子组件通信，因为不论你是否撇开 context ，结论都是一样的。props 是父组件传递给子组件的一些变量，在函数组件中，接收一个参数 props 来获取；而在类组件中，使用 this.props 拿到它。在子组件中，获取父组件传过来的函数 changeTheme ， 并绑定到按钮的点击事件上。12345function Toolbar(props) &#123; return ( &lt;button onClick=&#123;props.changeTheme&#125;&gt;&#123;props.children&#125;&lt;/button&gt; );&#125; 在父组件中，调用子组件并传值。1234567891011121314151617181920class App extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; theme: themes.light &#125;; this.setLightTheme = () =&gt; &#123; this.setState(&#123; theme: themes.light &#125;); &#125;; &#125; render() &#123; return ( &lt;div&gt; &lt;Toolbar changeTheme=&#123;this.setLightTheme&#125;&gt;光明&lt;/Toolbar&gt; &lt;/div&gt; ); &#125;&#125; 如果你知道子组件是一个 button ，你甚至可以直接在 Toolbar 上绑定 onClick 事件，然后子组件直接获取所有的 props 从而拿到点击事件。像这样1234// 父组件&lt;Toolbar onClick=&#123;this.setLightTheme&#125;&gt;光明&lt;/Toolbar&gt;// 子组件&lt;button &#123;...props&#125; /&gt; By the way, 其中 props.children 可以获取子节点，因此你可以通过这个直接将孙子组件放到父组件上。比如12345&lt;div&gt; &lt;Toolbar&gt; &lt;GrandSon onClick=&#123;this.xxx&#125; /&gt; &lt;/Toolbar&gt;&lt;/div&gt; 渲染出来就是12345&lt;div&gt; &lt;button&gt; &lt;GrandSon onClick=&#123;this.xxx&#125; /&gt; &lt;/button&gt;&lt;/div&gt; 使用 Provider 给 Consumer 传递函数修改通过 context 的 provider value 来传递变量的同时传递一个改变这个变量的函数。首先创建一个父组件，组件的 state 为 theme 和 setTheme, 然后在 Provider 里把 this.state 传过去。1234567891011121314151617181920class App extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; theme: themes.light, setTheme: () =&gt; &#123; this.setState((state) =&gt; (&#123; theme: state.theme === themes.dark ? themes.light : themes.dark &#125;)); &#125; &#125;; &#125; render() &#123; return ( &lt;ThemeContext.Provider value=&#123;this.state&#125;&gt; &lt;SetButton&gt;set theme&lt;/SetButton&gt; &lt;/ThemeContext.Provider&gt; ); &#125;&#125; 子组件在获取 context 的时候拿到 setTheme 的值，然后将 setTheme 事件绑定到 button 点击事件上。12345678class SetButton extends React.Component &#123; render() &#123; let props = this.props; let &#123; setTheme &#125; = this.context; return &lt;button onClick=&#123;setTheme&#125;&gt;&#123;props.children&#125;&lt;/button&gt;; &#125;&#125;SetButton.contextType = ThemeContext;","categories":[{"name":"计算机","slug":"计算机","permalink":"http://yoursite.com/categories/计算机/"},{"name":"前端","slug":"计算机/前端","permalink":"http://yoursite.com/categories/计算机/前端/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"},{"name":"context","slug":"context","permalink":"http://yoursite.com/tags/context/"}]},{"title":"redux使用指南","slug":"redux使用指南","date":"2021-03-27T03:40:47.000Z","updated":"2022-11-25T06:28:53.837Z","comments":true,"path":"2021/03/27/redux使用指南/","link":"","permalink":"http://yoursite.com/2021/03/27/redux使用指南/","excerpt":"","text":"什么时候使用redux 帮助我们进行状态（数据）管理。如果你可以不用，那么就没有必要用。如果应用中有以下场景可以考虑使用： 某个组件的状态需要共享 某个组件需要在任何地方都可以拿到 一个组件需要改变全局状态 一个组件需要改变另一个组件的状态 redux 思路所有的变量和处理函数都放在 store 里。var store = Redux.createStore(reducer)变量用 state 存储，处理函数是 action . reducer 是一个函数，接收旧的 state , 返回新的 state . 并且负责 state 的初始化和 action 的分类处理 . reducer = function(state, action){...}action 参数是一个对象 {type: &quot;&quot;, payload: &quot;&quot;} , 其中 type 表示 action 类型， payload 是 action 函数 的参数。外部获取变量使用 store.getState() 拿到 state 的值。store.subscribe(render) 用来监听 action ，一旦 action 被触发 (dispatch) 了，就执行 render 函数。 render 函数负责刷新页面。store.dispatch({ type: &quot;add&quot;, payload: 1 }) 触发一个类型为 “add” 的 action ， 并且传入参数 1 。在需要调用的时候调用。 原生 js + redux原生 js + redux Demoredux 作为一个状态管理工具，同样适用于原生 js 。这里用它实现一个点击加一的效果。 在 index.html 里创建一个 id 为 app 的 div 作为根元素。 安装 redux 包 声明一个 reducer 函数，传递两个参数 state (数据) 和 action (类型和函数参数) 。 1234567891011var reducer = function (state, action) &#123; state = state || &#123; // init state number: 0 &#125;; switch (action.type) &#123; // 事件处理 case &quot;add&quot;: return &#123; number: state.number + action.payload &#125;; default: return state; &#125;&#125;; 根据 reducer 创建 store 12import &#123; createStore &#125; from &quot;redux&quot;;var store = createStore(reducer); 监听 store 里边的改动。store.subscribe(render) 创建 render 函数 1234567function render() &#123; let str = ` &lt;div id=&quot;display&quot;&gt;$&#123;store.getState().number&#125;&lt;/div&gt; &lt;button id=&quot;add1&quot;&gt;点我加一&lt;/button&gt; `; document.getElementById(&quot;app&quot;).innerHTML = str;&#125; 执行 render 函数，渲染页面。render() 给 button 添加事件监听，在点击了按钮之后执行 store.dispatch ，发布时间。这里因为 render 的时候会重新弄一个 button 上去，并不是原先的 button 了，如果直接监听 button 的点击事件的话，那么这个函数只能执行一次。所以采用事件委托，监听根节点 #app 的点击事件，然后判断如果是在 button 上的点击则执行接下来的语句。12345document.getElementById(&quot;app&quot;).addEventListener(&quot;click&quot;, (e) =&gt; &#123; if (e.target.id === &quot;add1&quot;) &#123; store.dispatch(&#123; type: &quot;add&quot;, payload: 1 &#125;); &#125;&#125;); 至此效果完成。可以看见我们创建了一个页面，然后给 button 添加了一个事件，如果点击了这个按钮，就发布（ dispatch ） 一个类型为 add 、 参数为 1 的事件。而 store.subscribe(render) 监听到了这个事件，并在响应之后调用 render 函数，从而刷新页面。 react + reduxreact + redux Demo和 react 结合的 redux 和上面几乎没有区别，只是页面的刷新从 js 的刷新变成了 react 的刷新。还是点击加一的例子，步骤 1~5 同上。其余代码如下123456789101112131415function App() &#123; function add() &#123; store.dispatch(&#123; type: &quot;add&quot;, payload: 1 &#125;); &#125; return ( &lt;div&gt; &lt;div&gt; &#123;store.getState().number&#125; &lt;/div&gt; &lt;button onClick=&#123;add&#125;&gt; 点我加一 &lt;/button&gt; &lt;/div&gt; );&#125;function render() &#123; ReactDOM.render(&lt;App /&gt;, document.getElementById(&quot;root&quot;));&#125;render(); react-reduxreact-redux Demoreact-redux 是一个单独的依赖包，为了更便捷地在 react 中使用 redux 。它把组件分成了 UI 组件和容器组件，UI 组件负责 UI 的呈现，而容器组件负责管理数据和逻辑。我们知道，redux 是用来帮助我们管理数据的一个工具。在 react-redux 中，如果一个组件既有 UI 又有业务逻辑，我们需要把它拆分为两个部分：外面是一个容器组件，里边包含一个 UI 组件。依然是这个点击加一的例子。 创建 reducer , 创建 store 使用 Provider 将 store 传给子组件 1234567import &#123; Provider &#125; from &quot;react-redux&quot;;ReactDOM.render( &lt;Provider store=&#123;store&#125;&gt; &lt;App /&gt; &lt;/Provider&gt;, rootElement); 在子组件 App 中接收 state . （创建一个 App.js 文件） 12345678function App(props) &#123; return ( &lt;div&gt; &lt;div&gt;&#123;props.number&#125;&lt;/div&gt; &lt;button onClick=&#123;props.add.bind(this)&#125;&gt;点我加一&lt;/button&gt; &lt;/div&gt; );&#125; 这个 App 就是 UI 组件，它没有自己的状态，直接接收 props 的 number 并展示在页面上。button 的 click 事件同样也是 props 传进来的。 创建 state 转换成 props 的函数 1234function mapStateToProps(state) &#123; const &#123; number &#125; = state; return &#123; number: number &#125;;&#125; 将 state.number 赋值给 props.number , 并返回一个新的对象。 创建 dispatch 转换成 props 的函数 12345const mapDispatchToProps = (dispatch) =&gt; &#123; return &#123; add: () =&gt; dispatch(&#123; type: &quot;add&quot;, payload: 1 &#125;) &#125;; &#125;; 这里传入的是 dispatch ， 返回一个对象，对象里边有一个 add 函数，在 App 组件中使用 props.add 即可引用该函数。 如果函数不复杂的话可以省去这一步，直接在 App 组件中使用 useDispatch 即可。 123const dispatch = useDispatch();...&lt;button onClick = &#123;()=&gt;&#123;dispatch(&#123; type: &quot;add&quot;, payload: 1 &#125;)&#125;&#125;&gt;...&lt;/button&gt; 连接 UI 和数据逻辑 1export default connect(mapStateToProps, mapDispatchToProps)(App); 这里的语法不要写错connection()() 第一个 connection() 的返回值是一个函数，然后 App 是返回的这个函数的参数， 形如这样 1234567function add(a)&#123; a=a+1 return function fn(b)&#123; return a+b &#125;&#125;console.log(add(1)(2)) react-redux 的好处在于在不污染全局变量的条件下，我们不需要将 store 层层传递，只需要在根节点上使用 Provider 就能够让所有的子组件获取 store 的值。 以上，如果出现异步操作，action 发出之后，过一段时间再执行 reducer ，那么需要使用中间件 (middleware)。 参考文献：阮一峰Redux 入门教程","categories":[{"name":"计算机","slug":"计算机","permalink":"http://yoursite.com/categories/计算机/"},{"name":"前端","slug":"计算机/前端","permalink":"http://yoursite.com/categories/计算机/前端/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"},{"name":"redux","slug":"redux","permalink":"http://yoursite.com/tags/redux/"},{"name":"react-redux","slug":"react-redux","permalink":"http://yoursite.com/tags/react-redux/"}]},{"title":"任意组件通信","slug":"任意组件通信","date":"2021-03-26T09:00:52.000Z","updated":"2022-11-25T06:28:53.837Z","comments":true,"path":"2021/03/26/任意组件通信/","link":"","permalink":"http://yoursite.com/2021/03/26/任意组件通信/","excerpt":"","text":"发布-订阅模式参考父子组件通信，如果兄弟组件通信的话，应该是子A传父-父传子B-子B传父-父传子A。如果堂兄弟…很麻烦，所以使用发布-订阅模式。假设有一个变量，在家族树里的每个人都需要用到。那么如果 成员 A 需要操作这个变量，就发布一个事件，说：”我要改这个变量了”。我们加一个人进来，观察这个公有变量的动态，一旦有人发布了 “我要改这个变量了” 这个事件，那么就做出相应的响应——修改这个变量，然后再把信息发布给父组件，由父组件把这个新变量层层传递下去，从而避免了子传父父再传子的尴尬局面。Demo下面实现一个简单的发布-订阅模式 写一个 eventHub ： 12345678910111213141516var fnLists = &#123;&#125;var eventHub = &#123; trigger(eventName, data) &#123; // 发布 let fnList = fnLists[eventName] if(!fnList) &#123; return &#125; for(let i = 0; i&lt;fnList.length; i++) &#123; fnList[i](data) &#125; &#125;, on(eventName, fn) &#123; // 订阅 if(!fnLists[eventName]) &#123; fnLists[eventName] = [] &#125; fnLists[eventName].push(fn) &#125;&#125; 添加全局变量和事件处理函数事件处理函数用来监听（订阅）事件并作出响应，通过管家来修改变量并更新页面，而不允许其他的组件擅自修改。 123456789101112var money = &#123; amount: 10000&#125;var x = &#123; init() &#123; eventHub.on(&quot;pay&quot;, function(data) &#123; // 订阅事件 &quot;pay&quot; money.amount -= data render() // 更新页面 &#125;) &#125;&#125;x.init() 组件内部发布事件 123456789101112class Son1 extends React.Component &#123; pay() &#123; eventHub.trigger(&quot;pay&quot;, 100) // 发布事件 &quot;pay&quot; &#125; render() &#123; return ( &lt;div className=&quot;son&quot;&gt;amount: &#123;this.props.amount&#125; &lt;button onClick=&#123;this.pay&#125;&gt;付款100&lt;/button&gt; &lt;/div&gt; ) &#125;&#125; reduxredux 帮助我们进行状态管理，在这里可以看做是发布-订阅模式的一个实现。它将变量声明和处理函数统一放到了 store 里边，然后使用 store.subscribe() 来订阅事件，使用 store.dispatch({type: “事件类型”, payload: “参数” }) 来发布事件。使用 redux 改写上面的 demo。 redux 帮我们封装了一个 eventHub ，所以不用写。但是要npm install redux 来下载它。 添加 store （添加全局变量和事件处理函数）。这里的事件处理函数会我们只需要关心值的变化，redux 会帮我们重新 render 页面。123456789101112131415import &#123; createStore &#125; from &quot;redux&quot;;function money(state, action) &#123; if (typeof state === &quot;undefined&quot;) &#123; return &#123; amount: 10000 &#125;; &#125; switch (action.type) &#123; case &quot;pay&quot;: return &#123; amount: state.amount - action.payload &#125;; default: return state; &#125;&#125;var store = createStore(money); 其中 money 的参数 state 是我们要使用的全局变量，而 action 是事件的类型，根据事件类型选择处理函数。所有的处理函数和全局变量都封装在了这里。通过 store.getState().amount 来获取 amount 的值。 dispatch 事件（组件内部发布事件）123456789101112class Son1 extends React.Component &#123; pay() &#123; store.dispatch(&#123; type: &quot;pay&quot;, payload: 100 &#125;); // 发布事件 &quot;pay&quot; &#125; render() &#123; return ( &lt;div className=&quot;son&quot;&gt;amount: &#123;this.props.amount&#125; &lt;button onClick=&#123;this.pay&#125;&gt;付款100&lt;/button&gt; &lt;/div&gt; ) &#125;&#125; ContextContext 给我们创造一个局部的全局变量（只在 provider 内部的 component 里算是全局变量，其他地方无法访问），同样可以用来做组件通信。使用 context 修改的 demo const MoneyContext = React.createContext({}); 创建一个 context。其中 {} 是初始化这个 context 的值。 提供一个你需要用的变量，和修改这个变量的方法。这里我们在根组件上设置 state 的值。这里因为是 state 里的值，在 setState 完成之后 react 会帮我们重新 render 页面，所以也只需要关心值的变化。 12345678this.state = &#123; amount: 10000, pay: (amount) =&gt; &#123; this.setState(&#123; amount: this.state.amount - amount &#125;); &#125;&#125;; 然后将 this.state 通过 Provider 的 value 属性传出去 123456&lt;MoneyContext.Provider value=&#123;this.state&#125;&gt; &lt;div&gt; &lt;Dad1 /&gt; &lt;Dad2 /&gt; &lt;/div&gt;&lt;/MoneyContext.Provider&gt; 在需要调用的地方使用 Consumer 接收这个值。 123456789101112&lt;MoneyContext.Consumer&gt; &#123;(value) =&gt; ( &lt;div className=&quot;dad&quot;&gt; Dad1 amount: &#123;value.amount&#125; &lt;button onClick=&#123;() =&gt; &#123; value.pay(10); &#125;&#125;&gt; 付款10 &lt;/button&gt; &lt;Son1 /&gt; &lt;Son2 /&gt; &lt;/div&gt; )&#125;&lt;/MoneyContext.Consumer&gt; 总的来说 使用 eventHub/eventBus 来通信。用一个组件来监听某个事件，另一个组件触发这个事件并传递参数，即可实现两个组件的通信。缺点是当事件很多的时候，代码会变得略复杂。 使用 redux ，每次操作的时候触发一个 action ，这个 action 会根据旧的 state 生成新的 state 。使用 store.subscribe 来监听 state 的变化，一旦 state 变化了就重新 render 页面。 使用 context ，创造一个局部的全局变量。然后通过 provider 将这个变量和修改变量的函数传递出去。使用 consumer 来接收变量和函数，调用函数从而实现通信。利用 class 组件内部的 this.state 来实现页面的 render 。","categories":[{"name":"计算机","slug":"计算机","permalink":"http://yoursite.com/categories/计算机/"},{"name":"前端","slug":"计算机/前端","permalink":"http://yoursite.com/categories/计算机/前端/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"},{"name":"context","slug":"context","permalink":"http://yoursite.com/tags/context/"},{"name":"redux","slug":"redux","permalink":"http://yoursite.com/tags/redux/"},{"name":"组件通信","slug":"组件通信","permalink":"http://yoursite.com/tags/组件通信/"},{"name":"eventHub","slug":"eventHub","permalink":"http://yoursite.com/tags/eventHub/"}]},{"title":"父子组件通信","slug":"父子组件通信","date":"2021-03-26T06:08:39.000Z","updated":"2022-11-25T06:28:53.838Z","comments":true,"path":"2021/03/26/父子组件通信/","link":"","permalink":"http://yoursite.com/2021/03/26/父子组件通信/","excerpt":"","text":"react 组件react 组件有 function 组件和 class 组件，在以前，function 组件和 class 组件最大的区别在于 function 组件没有自己的状态。当然，后边使用 useState 另说，这里不做讨论。如果一个函数组件，需要做一个点击按钮加一的效果的话，需要先声明一个全局变量，然后再给按钮绑定 add 函数，在点击了之后重新 render 页面。demo类组件实现点击加一效果则不需要全局变量，可以直接在组件内部通过 this.state 来声明局部变量，需要修改变量的时候使用 react 提供的 this.setState 来修改变量。demo为什么函数组件不使用局部变量呢，因为函数组件重新 render 的话会把函数内部的变量重置，而类组件只是重新调用 render 函数，不影响 constructor 里的 this.state。关于 setState: 不能直接修改 state ，而要使用 setState。而且在使用 setState 给某个变量赋值的时候，不会覆盖掉其他的变量。比如 12this.state = &#123;a: 1, b: 2&#125;this.setState(&#123;b: 3&#125;) // 这一步不会把 a: 1 这个键值对覆盖掉。 react 会把多个 setState 合并成一个。比如 1234// a: 0this.setState(&#123;a: this.state.a+2&#125;)this.setState(&#123;a: this.state.a+1&#125;)// a: 1 得到的结果是 a: 1 ，因为前面的被后面的覆盖掉了。而如果你想要分两次调用的话，则需要借助函数。 12345678// a: 0 this.setState(&#123; number: this.state.number + 2 &#125;) this.setState((state)=&gt;&#123; return &#123;number: state.number + 1&#125; &#125;) // a: 3 使用第二个参数传入一个回调函数也是可以的 12345this.setState(&#123; number: this.state.number + 2&#125;, ()=&gt;&#123; number: this.state.number + 1&#125;) 此外，react 在 setState 之后，如果检查到了页面的变化，会主动去重新 render 局部更新页面（找到需要更新哪些地方的过程叫做 DOM diff）。 组件通信之父传子父组件要给子组件传递信息的话，使用 props 直接传递即可。比如说父组件有一个 number ，要在子组件中显示，那么直接在调用子组件的时候 &lt;Son number={this.state.number} /&gt;子组件使用 props 接收父组件传过来的参数123function Son(props) &#123; return &lt;div&gt;&#123;props.number&#125;&lt;/div&gt;&#125; 对于 class 组件也一样12345class Son extends React.Component &#123; render() &#123; return &lt;div&gt;&#123;this.props.number&#125;&lt;/div&gt; &#125;&#125; 原则上不要去修改父组件传进来的 props 。 另， props.children 可以获取子节点。12345&lt;Son&gt; &lt;h1&gt;hello&lt;/h1&gt; &lt;/Son&gt;function Son(props) &#123; return &lt;div&gt;&#123;props.children&#125;&lt;/div&gt;&#125;// 得到的就是 &lt;div&gt; &lt;h1&gt;hello&lt;/h1&gt; &lt;/div&gt; 组件通信之子传父子组件如果要传递信息给父组件，先由父组件通过 props 传递一个函数给子组件，然后子组件在一定的时候调用这个函数，把数据放在函数的参数里。demo","categories":[{"name":"计算机","slug":"计算机","permalink":"http://yoursite.com/categories/计算机/"},{"name":"前端","slug":"计算机/前端","permalink":"http://yoursite.com/categories/计算机/前端/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"},{"name":"组件通信","slug":"组件通信","permalink":"http://yoursite.com/tags/组件通信/"}]},{"title":"react背景知识","slug":"react背景知识","date":"2021-03-25T07:17:53.000Z","updated":"2022-11-25T06:28:53.836Z","comments":true,"path":"2021/03/25/react背景知识/","link":"","permalink":"http://yoursite.com/2021/03/25/react背景知识/","excerpt":"","text":"网页三要素：HTML、CSS and JS，在 react 里应该是什么样子的呢？ HTMLreact 没有 HTML 。这样说有点绝对，但是并不是完全不正确。你使用 create-react-app 创建一个 react 项目的时候，会发现在 public 文件夹下有一个 index.html 文件，里边有一个 id 为 root 的 div 。但是你要知道，我们写的所有代码，都应该是在 src 文件夹下的。我们不需要去修改这个唯一的 html 文件，为什么？抛开 react ，如果我们需要修改页面中的某个东西的时候，我们会怎么做？获取元素，修改元素，然后再把元素放回去。而 react 给了我们另一种可能——创建一个元素，然后放到页面。需要更新的时候创建一个新的元素，然后替换掉之前的元素。省去了从页面获取元素的那一步。还是那句话， react 没有 HTML 。平时写在 html 文件里的东西， react 放到了 JavaScript 里边。react 使用 React.createElement(&quot;div&quot;) 来创建一个 &lt;div /&gt; ，用 React.render(React.createElement(&quot;div&quot;), document.querySelector(&quot;#root&quot;)) 将 &lt;div /&gt; 挂到 id 为 root 的元素下。在 react 中，html 唯一的作用就是提供一个节点，让 js 把生成的元素挂到这个节点上。这样我们在需要修改 DOM 元素的时候，只需要用 js 直接修改，然后再重新 render ，将修改好的虚拟的 DOM 元素渲染到页面。省去了之前从页面获取 DOM 元素的步骤。 关于虚拟 DOMDOM 全称 Document Object Model ，文档对象模型，将 html 页面元素与一个个对象相对应，方便我们使用 js 来操控 html 文档。比如 var x = document.querySelector(&quot;#root&quot;),我们通过这段代码从 html 页面上获取了一个真实的 DOM 元素。变量 x 对应着页面上一个 id 为 root 的节点。而我们使用const x = React.createElement(&quot;div&quot;)则创建了一个标签为 div 的虚拟 DOM ，它与页面上的 div 相对应。总的来说，虚拟 DOM 是表示 DOM 节点的 js 对象，对应页面的真实的 DOM 元素。 JavaScript如果我想往页面加一个 button ，那么我应该这样写 React.render(React.createElement(&quot;button&quot;), document.querySelector(&quot;#root&quot;)) ，如果这个 button 需要绑定事件，那么应该使用123React.createElement(&quot;button&quot;, &#123; onClick: ()=&gt;&#123;console.log(&quot;here are we&quot;)&#125;&#125;, &quot;Click me&quot;) 其中第一个参数是元素标签；第二个参数是一个对象，上边写了元素属性；第三个参数是元素的内容。这样我们创建好了一个虚拟 DOM。感觉很麻烦。所以有了 jsx 语法。jsx 做了什么呢？它允许我们在 js 里写一段看上去像 html 的代码。比如上述的 button 创建，你可以这样1&lt;button onClick=&#123;()=&gt;console.log(&quot;here are we&quot;)&#125;&gt;Click me&lt;/button&gt; 其中{}里边是 js 的变量，如果不加的话会默认把它当做字符串。需要注意的是在这里 onClick 是给 button 绑定一个事件，如果你直接写 onClick = {console.log(1)} ，意思是把 console.log(1) 当做一个事件绑定上去，于是在绑定事件的时候会执行这段代码。所以需要使用一个函数把它包裹起来，这样才是在点击按钮的时候执行这个匿名函数。另，给函数加 class 的话用的是 className=&quot;xxx&quot; 而不是 html 中的 class=&quot;xxx&quot;。 CSSreact 里的 css 有两种方案。 传统方案传统的给元素加 class ，内容与样式分离。css 写在 css 文件里，然后 import &quot;./style.css&quot; 引入 css 。这种方法的一个弊端在于我们需要特别注意 class 的互相影响问题。如果组件 A 有一个叫做 title 的类，而它引用的另一个组件 B 同样也有一个 title 类，B 组件会继承 A 组件设置的 title 的样式。而为了干掉这个不确定的因素，部分人会选择以组件名为前缀的 class 名字，这样可以有效防止各组件之间的样式冲突。参考 BEM 命名规范。 CSS in JS因为上一个方案命名的繁琐为人诟病，而 css 没有办法做到自动区分两个重名的 class ，所以有人想，不要 css 了。根据这个思路，很多人，想了很多不同的解决方案。在 github 搜索 “css in js” 可以看到一个完整的列表——版本号、star 数、下载量、package 名，你可以根据需要自行选择好用的方案。这里介绍三种 styled-components 在组件内部的 js 文件中写样式代码。 12345678// 样式const Title = styled.h1` font-size: 1.5em; text-align: center; color: palevioletred;`;// jsx&lt;Title&gt; hello &lt;/Title&gt; 组件之间是彼此分离的，而组件内部内容样式和行为杂糅在了一起，好处是不论这个组件写的如何，不会影响到其他的组件。 react-css-module 配置略麻烦，解决方案比前面的那种纯净一点。 123import CSSModules from &apos;react-css-modules&apos;;import styles from &apos;./style.css&apos;;&lt;h1 styleName=&apos;title&apos;&gt;hello&lt;/h1&gt; emotion 语法繁琐，有点像内联样式。 123/** @jsx jsx */import &#123; jsx &#125; from &apos;@emotion/react&apos;&lt;h1 css=&#123;&#123; color: &apos;red&apos; &#125;&#125;&gt; hello &lt;/h1&gt; 具体选择什么方案自然是仁者见仁，但是需要注意的是，如果你是打算要建一个 UI 库，那么请选择传统方案。在 CSS in JS 方案中，虽然我们没有写类名，但是在运行的时候， js 会自动为我们生成一个类名，你可以在浏览器的检查元素里看见。在你自己的应用中，这不是什么问题。但是如果是建 UI 库，别人不知道类名，就无法覆盖样式。 以上， react 可能只有 js ….","categories":[{"name":"计算机","slug":"计算机","permalink":"http://yoursite.com/categories/计算机/"},{"name":"前端","slug":"计算机/前端","permalink":"http://yoursite.com/categories/计算机/前端/"},{"name":"react","slug":"计算机/前端/react","permalink":"http://yoursite.com/categories/计算机/前端/react/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"react开发环境搭建","slug":"react开发环境搭建","date":"2021-03-25T02:36:26.000Z","updated":"2022-11-25T06:28:53.836Z","comments":true,"path":"2021/03/25/react开发环境搭建/","link":"","permalink":"http://yoursite.com/2021/03/25/react开发环境搭建/","excerpt":"","text":"codesandboxcodesandbox 可以帮助你快速开始写你的 react 项目。你可以在这里直接创建一个 react 项目。新建 sandbox 的时候选择 React 模板，需要依赖的时候在文件下方的 Dependencies 里边添加依赖即可。除此之外，它还支持链接到你的 github ， 你可以将这里的项目直接 push 到你的 github 仓库中。点击右侧的猫，输入项目名，然后点击 Create new respository on Github 即可。当然同理，你也可以将你的 github project 导入进来。使用流畅，不过不支持自定义 webpack 配置，需要的可以点击 topbar 上的 File ，export 到本地进行开发。 原始的 react在你的任意项目中，或者是在 jsbin 等在线编辑器中，引入 react 和 react-dom 包，即可进行开发。 引入资源文件。在 BootCDN 中搜索 react ， 选择 ./umd/react.development.min.js 开发包，引入到项目中。 react-dom 同理。 开始写。你可以参考并改写这里的代码来尝试 react 。 123456function App() &#123; return React.createElement(&quot;button&quot;, &#123; onClick: ()=&gt;alert(1111) &#125;, &quot;Click&quot;)&#125;ReactDOM.render(React.createElement(App), document.getElementById(&quot;xxx&quot;)) 或者 123ReactDOM.render(React.createElement(&quot;button&quot;, &#123; onClick: ()=&gt;alert(1111) &#125;, &quot;Click&quot;), document.getElementById(&quot;xxx&quot;)) 以上代码效果相同，都是创建一个 button 并挂到 id 为 “xxx” 的页面元素下。 使用 jsx 的 reactjsx 省去了 React.createElement() , 直接使用类似于 html 的语法来写代码，而配置其他的工具来将代码解析成 React.createElement() 。使用 babel 在线翻译 可以实时查看 jsx 翻译成 js 之后的代码。 在线开发在 jsbin 中，点击 javascript 可以切换到 jsx 语法，你可以在此书写你的代码。这是使用 jsx 语法改写的简单的例子，和上一步中的代码功能一致。1234function App() &#123; return &lt;button onClick=&#123;()=&gt;alert(1111)&#125;&gt;Click Me&lt;/button&gt;&#125;ReactDOM.render(&lt;App/&gt;, document.getElementById(&quot;xxx&quot;)) 本地开发本地开发和使用 jsbin 不同的是你需要自己配置 babel 来解析 JSX 代码。如果碰到问题请参考Babel官方文档 创建一个文件夹，用来存放你的环境和源码。 npm init 创建一个合法的 package.json 文件 npm install --save-dev @babel/core @babel/cli @babel/preset-env npm install --save @babel/polyfill执行这两行命令安装 babel 包。 创建一个 config 文件 babel.config.json, 代码如下： 1234567891011121314151617&#123; &quot;presets&quot;: [ [ &quot;@babel/env&quot;, &#123; &quot;targets&quot;: &#123; &quot;edge&quot;: &quot;17&quot;, &quot;firefox&quot;: &quot;60&quot;, &quot;chrome&quot;: &quot;67&quot;, &quot;safari&quot;: &quot;11.1&quot; &#125;, &quot;useBuiltIns&quot;: &quot;usage&quot;, &quot;corejs&quot;: &quot;3.6.5&quot; &#125; ] ] &#125; npm install --save-dev @babel/plugin-transform-react-jsx 安装 plugin-transform-react-jsx ，这样才能识别 jsx 语法。 修改 babel.config.json 文件，添加 12345&quot;plugins&quot;: [ [ &quot;@babel/plugin-transform-react-jsx&quot; ] ] 与 presets 平级。 npx babel main.jsx --out-file main-compiled.js 将 main.jsx 文件编译成 main-compiled.js 文件，然后在你的 index.html 中引入 main-compiled.js 文件即可。当然，不要忘了在你的 index.html 文件中引入 react 和 react-dom . npx babel src/js --watch --out-dir dist/js 如果你需要实时更新的话，这个命令会帮你开一个进程，实时关注你的 src/js 文件夹内的更新，一旦有了改动，会输出到 dist/js 文件夹中。 create-react-app借助 create-react-app 来构建一个本地项目。 创建一个 demo 文件夹，然后进入 demo，执行 yarn add create-react-app 或者 npm install create-react-app。或者全局安装。 npx create-react-app my-app 或者 yarn create react-app my-app 创建一个名字是 my-app 的项目。 此时你已经得到一个完整的 react 项目了，cd my-app 然后执行npm start 或者 yarn start 可以开启一个本地服务，预览你的项目。 执行 npm run build 或者 yarn build 之后可以得到一个 build 文件夹。在你的 package.json 文件中添加 &quot;homepage&quot;: &quot;https://yourusername.github.io/my-app/build&quot; 之后再进行 build ，然后将你的代码上传至你的 GitHub ，配置 github page 之后，可以在线预览你的项目。 附（各文件作用）：1234567package.json 依赖和脚本等东西yarn.lock 目前安装的东西，真实使用的东西。一个记录。src 所有的源码 index.js 入口文件 App.js 业务逻辑public 公开的文件，一般是常年不更新的代码build 构建之后的代码","categories":[{"name":"计算机","slug":"计算机","permalink":"http://yoursite.com/categories/计算机/"},{"name":"前端","slug":"计算机/前端","permalink":"http://yoursite.com/categories/计算机/前端/"},{"name":"react","slug":"计算机/前端/react","permalink":"http://yoursite.com/categories/计算机/前端/react/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"},{"name":"create-react-app","slug":"create-react-app","permalink":"http://yoursite.com/tags/create-react-app/"},{"name":"babel","slug":"babel","permalink":"http://yoursite.com/tags/babel/"}]},{"title":"webpack","slug":"webpack","date":"2021-02-22T05:13:44.000Z","updated":"2022-11-25T06:28:53.837Z","comments":true,"path":"2021/02/22/webpack/","link":"","permalink":"http://yoursite.com/2021/02/22/webpack/","excerpt":"","text":"前言 webpack 是什么？它是一个开发工具。 它有什么用？将你写的源码编译成浏览器能够看懂的代码。 什么时候用？布置我们的开发环境的时候用。 或许这样的描述仍然不够清晰，那么不妨想象一下，如果没有 webpack ，会怎么样？如果我们想要在一个项目中使用 sass ， 而 sass 不能被浏览器正确地解析，那么我们是不是需要一个 sass 解析的工具，从而能让我们开发的时候能够使用 sass ？ node-sass 就是用来做这件事情的。ECMA 规范不断地发展，而用户多的时候总有那么些人用的是旧版本的浏览器，为了做兼容我们难道要一直使用旧的属性吗（ Can I use 可以搜索属性是否存在兼容性问题 ）？当然不是。Babel 就是用来解决这个问题的，它可以把我们的新代码重新编译成浏览器能看得懂的代码。如你所见，我们使用新的技术总是会遇见很多的阻力，为了能赶上潮流，我们不得不借助一些工具。而前端的潮流变化太快，工具也变得更多了，那么如果有一种东西，能够集合所有的这些工具，会不会让我们的开发更方便一些？ webpack 就是这样做的。它集成了这些工具，让我们用起来更方便一些。这里我先介绍一下不使用 webpack 的情况，再来讨论如果使用 webpack 的话应该是怎么样的。 一些工具的使用SassSass 是 Ruby 社区发明的一种 css 语言，使用 Sass 可以使你的 css 写起来更加的简洁，但是浏览器不认识。*.sass 和 *.scss 都是 Sass 文件， 语法略微不同。*.scss 比 *.sass 多了括号。我们需要一个工具来把我们写的 Sass 翻译成浏览器可以识别的 css ，这就是 node-sass。node-sass 给我们提供了一个 -watch 参数，可以实现自动化实时更新，免去了我们每次修改 Sass 文件之后都重新运行编译命令的麻烦。1234npm install -g node-sass // 全局安装 node-sassnode-sass main.scss main.css // 将 main.scss 翻译成 main.cssnode-sass src/css -o dist/css // 将 src/css 目录下的所有 Sass 文件 翻译成 css 并输出到 dist/css 目录下node-sass src/css/main.scss dist/css/main.css -w // 自动实时翻译 使用 node-sass src/css -o dist/css -w 可以实时监听 src/css 文件夹下所有的 scss 文件的改动并输出到 dist/css 文件夹下。 Babelnode-sass 是翻译 sass 的工具，Babel 则是翻译 js 的工具。js 在不断地更新，ES5、ES6，TypeScript，等等，使用 Babel 可以将它们统一翻译为所有浏览器都可以接受的js。Babel官方文档 npm init 创建一个合法的 package.json 文件 npx babel main.js --out-file main-compiled.js 使用 npx babel 代替 ./node_modules/.bin/babel。--out-file 可以简写为 -o. npx babel src/js --watch --out-dir dist/js --out-dir 可以简写为 -d, --watch 可以简写为 -w. 当你 install 的时候，添加 -g 参数代表全局安装，否则为项目内部安装。项目安装的话会默认安装在 node_modules 里边，运行的时候需要用./node_modules/.bin/babel main.js -o compiled.js，而如果是全局安装的话，命令会包含在 path 里，在命令行直接输入 babel main.js -o compiled.js 即可。 watch-cli在上面的步骤里，我们了解了 node-sass 和 babel ，一个用来实时监听 scss 的改动，另一个用来实时监听 js 的改动。但这还不够，完整的代码里还需要 html。我们用 watch-cli 来监听 html 的改动，一旦它有了改动，就自动复制到 dist 目录下。 如此我们所有的代码应该都在 dist 目录下了。但是这样我们在写代码的时候同时开了三个进程，才能保证我们的代码能够正常地运行。而如果你使用 webpack ，则只需要开一个 webpack 的进程即可。 回到 webpackwebpack 官方网站 webpack 的基础使用这里我们创建一个 demo 来尝试做这件事情。项目目录如下：123456webpackDemo src // 存放你要写的代码 index.js style.scss test.html dist // 存放webpack生成的代码 webpack 的安装与配置 webpack 的安装：npm install --save-dev webpack 创建一个 webpack.config.js 文件，并在里边添加配置如下： 123456789const path = require(&apos;path&apos;);module.exports = &#123; mode: &quot;development&quot;, // 官网上没写这一句，但是不加的话会报错。 entry: &apos;src/index.js&apos;, // 你的 js 入口文件 output: &#123; filename: &apos;main.js&apos;, // 编译之后输出的文件 path: path.resolve(__dirname, &apos;dist/js&apos;), // 编译之后输出的文件夹 &#125;,&#125;; 应用配置（不是很确定是否需要）npx webpack --config webpack.config.js 运行 npx webpack，这个命令会执行代码的编译，在你修改代码完成之后执行这个命令，会将你的改动重新计算到 dist 文件夹里。 生成 html 安装 html-webpack-plugin 插件（貌似还要安装 lodash） 12npm install --save-dev html-webpack-pluginnpm install --save-dev lodash 在 webpack.config.js 文件中添加如下配置： 12345module.exports = &#123; plugins: [new HtmlWebpackPlugin(&#123; template: &apos;src/test.html&apos; // 这里不加的话会给你默认创建一个 html，如果加了的话就会参考这个里边的内容创建 html &#125;)],&#125;; 更多功能看这里 配置 sass官方文档看这里 安装 sass-loader 123npm install sass-loader sass webpack --save-devnpm install style-loadernpm install css-loader 添加配置 1234567891011121314151617module.exports = &#123; module: &#123; rules: [ &#123; test: /\\.s[ac]ss$/i, use: [ // Creates `style` nodes from JS strings &quot;style-loader&quot;, // Translates CSS into CommonJS &quot;css-loader&quot;, // Compiles Sass to CSS &quot;sass-loader&quot;, ], &#125;, ], &#125;,&#125;; 在你的 index.js 文件中添加import &quot;./style.scss&quot;;对这个 style 文件进行引入 配置 babel官方文档看这里 安装 babel-loader npm install -D babel-loader @babel/core @babel/preset-env webpack 添加配置 1234567891011121314module: &#123; rules: [ &#123; test: /\\.m?js$/, exclude: /(node_modules|bower_components)/, use: &#123; loader: &apos;babel-loader&apos;, options: &#123; presets: [&apos;@babel/preset-env&apos;] &#125; &#125; &#125; ]&#125; 如果你有其他的 js 文件，同样要在我们的入口文件 index.js 里边 import。index.js 12import x form &apos;./module-1&apos;x() module1.js 12function fn() &#123;console.log(1)&#125;export default fn 添加实时更新在你的 webpack.config.js 文件中添加123module.exports = &#123; watch: true,&#125; todo打包工具的发展：grunt -&gt; gulp -&gt; webpack -&gt; parcel? vite? webpack 相关面试题, 你对webpack的理解？ 打包。比如使用 sass-loader 进行 sass 文件的翻译。 模块化。index.js 作为入口文件，css 和 js 都在这里进行 import 。 而 webpack 翻译这个入口文件的时候，将引入的那些文件也翻译出来，将这些所有的文件都翻译成一个文件。","categories":[{"name":"计算机","slug":"计算机","permalink":"http://yoursite.com/categories/计算机/"},{"name":"前端","slug":"计算机/前端","permalink":"http://yoursite.com/categories/计算机/前端/"}],"tags":[]},{"title":"浏览器信息存储方式","slug":"浏览器信息存储方式","date":"2021-02-03T05:37:41.000Z","updated":"2022-11-25T06:28:53.838Z","comments":true,"path":"2021/02/03/浏览器信息存储方式/","link":"","permalink":"http://yoursite.com/2021/02/03/浏览器信息存储方式/","excerpt":"","text":"Cookie和Session的关系关于Cookie的具体使用我们可以见这篇登录的前后端合作博客，这里我们只从理论方面来讨论。打开浏览器的控制台 -&gt; Application tab页 -&gt; Storage -&gt; Cookies我们可以看到当前url下存储的所有Cookie，这些Cookie记录了我们的一些信息，当我们清除掉Cookie之后，可能需要重新登录这个网站。通俗的来讲，我们说Cookie存储了用户信息。但是，你会发现，你看见的Cookie的键值对是一串接近于乱码的字符串。为什么？这就涉及到了Session。Session保存在服务器端，服务器关闭则Session清空，但一般服务器不会直接关闭，关闭也会把它先存起来。用户登录的时候随机一个SessionID，然后用Cookie保存SessionID。通过这个SessionID去找到对应的信息。写成伪代码大概是这个样子：123SessionID = 随机数Sessions[SessionID] = 用户信息Set-Cookie: xxx=SessionID 读取的时候12get Cookie xxxSessions[xxx]得到用户信息 为什么要这样麻烦？找到你的Cookie，修改它的值。如你所见，Cookie的值可以被用户修改。如果说Cookie里存了邮箱，然后服务器通过这个邮箱去拿到用户的隐私信息，那么只要张三知道李四的邮箱，就可以通过修改自己Cookie里的邮箱，拿到李四的隐私信息。所以要用随机数——sessionID。随机数在很大的程度上保护了用户的隐私信息。Session存在服务器端，对用户不可见，用户没有办法进行修改。我们随机一个SessionID，Sessions[SessionID] = 用户信息用这样一个键值对来存储用户信息。Cookie只用来存储SessionID，所以你看到的Cookie基本上都是一串接近于乱码的字符串。 Cookie和Session使用Cookie的使用： 用户登录，服务器拿到用户信息，通过Set-Cookie给客户端一串字符串 客户端拿到这段字符串之后，存到本地。每次访问相同域名的时候都会带上这段字符串，相当于一个身份标识。 Cookie会在本地保存一段时间之后自动过期。 前端不要读写Cookie，用localStorage做持久化存储。 Cookie设置过期时间： 如果不设置的话会自动在浏览器关闭之后删除Cookie 设置过期时间（Expires），比如Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2021 07:28:00 GMT; 设置有效期（Max-Age），比如Set-Cookie: id=a3fWa; Max-Age=1000; 删除Cookie： 图形界面删除f12进入控制台 -&gt; Application -&gt; Storage -&gt; Cookies -&gt; clear all 代码删除获取Cookie然后把过期时间设为现在或者过去。 Session的使用： 用户登录，服务器拿到用户信息之后，生成一个随机数SessionID，在Session对象里面生成一个SessionID与用户信息的键值对，然后通过Cookie给客户端返回这个SessionID 客户端拿到SessionID之后，存到本地。下次再访问相同域名的时候带上这个SessionID给服务器。 服务器再次拿到SessionID之后会在Session对象里去找这个SessionID对应的用户信息。 服务器在这块内存里存储了所有的Session信息。 LocalStorage与SessionStorageLocalStorage的使用localStorage是html5(所有新的技术统称为html5)提供的一个API，一般用来做本地的持久化存储，在LocalStorage之前，一旦刷新页面，这个页面上的所有东西全部会被销毁，不会保存下来。而LocalStorage会保存在本地的某个文件里。典型的使用场景是在用户第一次进入这个网页的时候给出提示信息：在页面进来之前读一下localStorage确认是否已经提示过，如果没有的话给出提示同时记录下我已经提示过了，如果提示过了的话就啥也不做。1234localStorage.setItem(&quot;aaa&quot;,&quot;bbb&quot;)localStorage.getItem(&quot;aaa&quot;)localStorage.clear()// localStorage只能存string，存别的会自动转化成string LocalStorage和SessionStorage的特征LocalStorage： LocalStorage与HTTP无关 HTTP不会带上LocalStorage的值 只有相同域名的页面才能互相读取LocalStorage（浏览器带的功能） 每个域名localStorage最大存储量为5M左右 常用场景：记录有没有提示过用户等一些没用的信息。不能记录密码等敏感信息。 永久有效，除非用户清理缓存（Chrome浏览器中按住ctrl+shift+delete，高级/Cookie及其他网站数据，清除数据） SessionStorage： 和localStorage差不多 会自动过期，关闭窗口之后看浏览器啥时候清除（基本是立即清除） Cookie、LocalStorage和SessionCookie的本质是HTTP协议的一个内容（Cookie是http头），每次向浏览器发送http请求的时候都会带上Cookie，最大为4k左右。localStorage的本质是浏览器上的一个hash表，是一个api，用来存一些没什么用的信息，与http没有关系，最大为5M左右，与Cookie的相同之处在于都存储在本地。Session的本质是服务器上的一个hash表，一般来说是基于Cookie实现，用来存储用户的隐私信息。 没什么用的记录：Session也可以不基于Cookie，用localStorage存储SessionID，然后通过POST请求把SessionID传给服务器SessionStorage和LocalStorage的过期时间不同。Cookie的过期时间一般和SessionStorage相同，但是可以后台设置。 HTTP缓存Cache-ControlCache-Control和Cookie一样，是HTTP协议的一个东西。Cache-Control用来加快请求的速度，使用max-age来设置多长时间内不发送新的请求。Cache-Control: max-age=&lt;seconds&gt;表示在多少秒内不接受相同的请求，直接用之前的那个，浏览器从内存/硬盘中获取之前的缓存。浏览器控制台打开，Network/Disable cache如果勾选上表示不从缓存里拿数据，直接发送请求。只有URL完全相同浏览器才会选择去获取之前的缓存，因此在实际使用的时候，可以设置一个很长时间的过期值（十几二十年的），然后通过修改URL让用户拿到最新的数据（./css/style.css?version=001）。也因此首页作为入口文件，不能设置 Cache-Control , 不然网站拿不到最新的 URL 值，用户在很长一段时间内永远没有办法获取最新的代码（浏览器貌似会自动禁用，但我们不能指着浏览器来修复自己代码的错误）。 Expires以前用的，用来加快请求的速度，和 Cache-Control 的区别在于设置的不是多久过期，而是设置什么时候过期，是一个确切的时间点。而且这个时间点用的是电脑的本地时间，如果你的电脑时间设置不对的话可能会出现一些问题。比如过期时间是2040/1/1 12:03:43，而你本地的时间设置成了2041/5/8 12:12:12，那么每次都会进行重新请求。如果设置了 Cache-Control , Expires 会被忽略。 ETagMD5 是一种摘要算法，用来对比两个文件的信息。对一个文件使用 MD5 计算一下，可以得到一串字符串，如果两个文件完全相同，那么得到的字符串也相同。所以常用来进行文件的比对。ETag就是基于 MD5 的。如果网页设置了ETag，那么发送HTTP请求的时候，会带一个对本地缓存中的文件进行 MD5 之后的字符串，然后与我们请求的服务器端的那个文件进行比对。如果相同则服务器不返回值，浏览器直接拿本地的缓存；如果不相同则返回新的文件。所以 ETag 和 Cache-Control 的区别在于，Cache-Control 如果是在时间内的话会直接不发送请求，而 ETag 每次都会发送请求，但是有可能不带数据回来（不从服务器端下载文件）。","categories":[{"name":"计算机","slug":"计算机","permalink":"http://yoursite.com/categories/计算机/"}],"tags":[{"name":"Cookie","slug":"Cookie","permalink":"http://yoursite.com/tags/Cookie/"},{"name":"LocalStorage","slug":"LocalStorage","permalink":"http://yoursite.com/tags/LocalStorage/"},{"name":"Session","slug":"Session","permalink":"http://yoursite.com/tags/Session/"},{"name":"Cache-Control","slug":"Cache-Control","permalink":"http://yoursite.com/tags/Cache-Control/"},{"name":"ETag","slug":"ETag","permalink":"http://yoursite.com/tags/ETag/"}]},{"title":"登录的前后端合作","slug":"登录的前后端合作","date":"2021-01-25T13:15:07.000Z","updated":"2022-11-25T06:28:53.838Z","comments":true,"path":"2021/01/25/登录的前后端合作/","link":"","permalink":"http://yoursite.com/2021/01/25/登录的前后端合作/","excerpt":"","text":"从创建用户到用户登录 用户注册。由前端的页面得到用户信息然后将需要的用户注册信息传给后端。 创建用户。后端拿到前端的用户信息之后，进行数据库的信息比对，如果信息无误，则插入到数据库。这里需要知道的是前端可以选择是否要进行字段合法性检测，后端必须要检查字段是否合法，因为用户可以通过curl直接访问网站而不经过浏览器页面。 用户登录。用户输入用户名和密码之后，点击登录按钮，前端将用户输入的信息提交给后端，后端拿到信息之后进行比对，如果用户名密码正确的话则允许登录，否则给出提示。 登录信息保存。浏览器使用Cookie来存储用户信息，如果你需要保持用户的登录状态，那么后端需要在用户登录成功之后将用户登录信息保存在Cookie里。 在页面展示用户信息。后端使用nodejs获取Cookie，然后通过Cookie的唯一字段去数据库里寻找需要展示的字段信息，将字段信息返回给前端，前端根据返回的信息进行页面展示。 开始写先写一个登录页面登录页面发请求123456789101112131415161718192021$(&quot;#signUpForm&quot;).on(&quot;submit&quot;, (e) =&gt; &#123; e.preventDefault() let hash = &#123;&#125; let keys = [&apos;userName&apos;, &apos;email&apos;, &apos;password&apos;, &apos;passwordComformation&apos;] keys.forEach((key) =&gt; &#123; hash[key] = $(&quot;#signUpForm&quot;).find(`[name=$&#123;key&#125;]`).val() &#125;) $.ajax(&#123; url: &apos;/signUp&apos;, method: &apos;POST&apos;, dataType: &apos;json&apos;, contentType: &apos;application/json&apos;, data: JSON.stringify(hash), error: function () &#123; console.log(&quot;error&quot;); &#125;, success: function () &#123; console.log(&quot;success&quot;); &#125; &#125;)&#125;) nodejs获取前端发送的请求因为数据是一点一点发送的，得到的是Buffer对象，要转成json格式1234request.on(&apos;data&apos;, chunk =&gt; &#123; let json = JSON.parse(chunk.toString()) console.log(json)&#125;); 数据合法性检测这个demo里我们需要检测的是email是否符合要求、以及password和passwordConfirmation是否匹配。前后端使用同一个约定字符串，后端负责返回错误类型，前端对这个错误类型进行解释说明并呈现给用户。 弄一个数据库因为是做一个demo，所以这里我们创建data.db文件作为一个简单的数据库。格式如下：12345[&#123; &quot;userName&quot;: &quot;xxx&quot;, &quot;email&quot;: &quot;aaa@bbb.cn&quot;, &quot;password&quot;: &quot;cc&quot;&#125;] 实际使用的时候，密码应该是加密存储，但是这里先不做那些。 往数据库里添加数据先读取数据文件，然后再往这个文件后面追加东西，再把数据写到数据文件里。123456789let users = fs.readFileSync(&apos;./database.db&apos;, &apos;utf8&apos;)users = JSON.parse(users)users.push(&#123; &quot;userName&quot;: userName, &quot;email&quot;: email, &quot;password&quot;: password&#125;)let userStr = JSON.stringify(users)fs.writeFileSync(&apos;./database.db&apos;, userStr) 对添加进数据库的数据进行筛选用户发送的数据可能是不对的，我们之前进行了数据本身的校验，但除此之外，大部分时候我们还需要将新的数据与数据库里其他的数据进行比较，这里我们设置注册邮箱必须唯一。读取数据库文件，然后对其进行遍历，如果邮箱地址存在则返回400，给出提示；如果不存在的话就将注册用户信息填入数据库并返回success。 用户登录添加登录的前端页面，并在后台添加登录接口，比对用户提交的登录信息，进行登录验证，如果验证通过则允许登录。用户登录之后直接跳转到主页面index。 使用Cookie储存登录用户的信息登录成功之后写入cookie123response.writeHead(200, &#123; &apos;Set-Cookie&apos;: [`sign_in_email=$&#123;data.email&#125;`,&quot;aaa=bbb&quot;,&quot;ccc=ddd&quot;,&quot;eee=fff&quot;]&#125;) 在主页读取cookie获取当前登录用户的信息读取cookie123456var cookies = &#123;&#125;;request.headers.cookie &amp;&amp; request.headers.cookie.split(&apos;;&apos;).forEach(function( Cookie ) &#123; var parts = Cookie.split(&apos;=&apos;); cookies[ parts[ 0 ].trim() ] = ( parts[ 1 ] || &apos;&apos; ).trim();&#125;);console.log(cookies) 获取了cookie之后再通过cookie的信息拿到你需要的用户信息，再把用户信息展示到页面上。 写在后面代码github地址：https://github.com/wenchuyang/simple-projects/tree/master/nodejs/signUp 关于Cookie 服务器通过Set-Cookie响应头设置Cookie 浏览器得到Cookie之后，每次请求都要带上Cookie 服务器通过读取Cookie得到登录用户的用户信息 Cookie可以手动修改，在浏览器控制台Application里查看cookie的值就可以修改。or js document.cookie。 Cookie存在C盘的一个文件里 Cookie存在有效期，浏览器决定过期时间，默认20分钟左右。后端可以强制设置有效期。 安全性因为用户可以篡改Cookie，所以我们换了另一种方案——浏览器信息存储方式","categories":[{"name":"计算机","slug":"计算机","permalink":"http://yoursite.com/categories/计算机/"},{"name":"前端","slug":"计算机/前端","permalink":"http://yoursite.com/categories/计算机/前端/"}],"tags":[]},{"title":"《如何阅读一本书》笔记","slug":"如何阅读一本书笔记","date":"2021-01-22T07:36:25.000Z","updated":"2022-11-25T06:28:53.837Z","comments":true,"path":"2021/01/22/如何阅读一本书笔记/","link":"","permalink":"http://yoursite.com/2021/01/22/如何阅读一本书笔记/","excerpt":"","text":"概要书名：《如何阅读一本书》作者：[美]莫提默·艾德勒，查尔斯·范多伦译者：郝明义，朱衣 这本书教人们使用不同的方法去阅读不同类型的书，并详细描述了阅读的不同层次和阅读时的注意事项。 你为什么要读那本书？当你阅读一本书的时候，你要清楚你的读书目的。(获得资讯、增进理解力、消遣)你为什么要读这本书？为了增加你对某个行业的理解?或者是对某件事情的理解?还是仅仅想要获得资讯，知道某件事情的来龙去脉?或者是just for fun? 你该如何读那本书？阅读分三个层次: 浏览、细读和主题阅读。 先看引言、目录，然后大致浏览，知道这是一本什么样的书，讲了什么。 仔细阅读这本书，其间不要去看别人的书评之类的东西。完成你自己对这本书的理解，完成你自己的评论。 辅助阅读去了解与这本书相关的其他的知识，进行主题阅读，建立知识结构网。 浏览一本书浏览的时候你要学会抓住有用的信息，作者引言、目录、推荐语，以及每个章节的开头几段结尾几段，把握整体，决定你是否要继续对这本书进行更深层次的阅读。这个阶段你需要对这本书进行图书分类，你知道这是哪一类的书，这本书是怎么个架构，这本书讲了什么，包含哪些部分? 需要控制在一定的时间内完成。 如果你觉得这本书值得你进一步花时间阅读，那你可以完成粗略的阅读。带着你前面得到的关于这本书的信息，从头到尾地读一遍这本书。然后完善你脑海中关于这本书的信息。对于比较难懂的书，你第一遍的时候可以略过那些难懂的部分，专心放在你能读懂的地方，读完它。在你把握住了这本书的整体之后，有空再去读第二遍。 先把握大的原则，然后再看细节。一本书的四个问题: 这本书在讲什么? 作者是如何发展他的论题的，分论点有哪些?分别是从哪里开始讲的? 作者讲的有道理吗?全部有道理还是部分有道理?你需要自己说出个所以然来。学会不要被作者的主观情绪所误导。 你真的需要看这本书吗?它是不是在浪费你的时间? 仔细阅读一本书 用一句话或一小段话来描述这本书到底写了些什么 为这本书写一段推荐语 与这本书相关的书单。这本书应该要归为哪一类。 按照你自己的思路给这本书归纳出一个架构。对作者的目录既不忽略也不盲从。 找出作者在问的问题或者作者想要解决的问题。 阅读不同类别的书籍 对于论述性的文章/书籍，请拿出中国学生与生俱来的划重点的本事来读。 对于小说性质的文章/书籍，找出文章脉络，找到作者要表达的重点。 读一本实用性的书时，你先确定你的目标是什么，确认这本书可以让你达到你的目的，或者至少让你进一步，这样才值得继续阅读 阅读小说的时候先不要怕人物太多捋不清，将自己代入故事，继续看下去。你总会逐渐记住谁是谁。 对于剧本（莎士比亚的戏剧等），把剧本大声地读出来。要慢慢读，就像是听众在听你说话一样，还是带着感情读 对于诗，先一口气读完，不要停。读者最好是知道关于这个作者的生平经历、这首诗的时代背景。然后去了解这首诗大概是写了什么，表达了什么。再是逐字逐句分析意思。理想与现实的冲突、爱与时间、生与死、入世出世、抱怨社会、抒发豪情壮志等等。 一首好诗可以用心研读，一读再读，并在你一生当中不断地想起这首诗。你会在诗中不断地找到新点子、新的乐趣与启示，对你自己及这个世界产生新的想法。 对于历史书，你如果想要了解真正的历史，不要听信某一个作者的一面之词，即使他尽量使文章足够客观。另外，不要只关心真正发生了什么，关心那些人为什么要那样做，才能以史为镜。除非你只是想找资料。 数学科学一类的书，并不全是给他们专业人士看的，有些书也是写给我们普罗大众的。看的时候不需要每个公式都去演算一遍，掌握重点就好。你要了解作者想要解决的是什么问题，然后看作者如何去解决这些问题。 数学既然是一种语言，那就拥有自己的字汇、文法与句法（Syntax），初学者一定要学会这些东西。特定的符号或符号之间的关系要记下来。 把数学看作是一门语言，一种沟通方式。把符号当做是另一种字词，你要知道符号代表的意义、符号与符号之间的关系，用这样的方法来阅读数学书。 阅读哲学书，发现问题，或者找到作者试图回答的答案。 主题阅读找到你的主题，找到与你主题相关的书籍，甚至于找到书中与你的主题相关的章节。此时你的阅读重点不在某本书，而是在你的主题。","categories":[{"name":"书籍","slug":"书籍","permalink":"http://yoursite.com/categories/书籍/"}],"tags":[{"name":"书籍","slug":"书籍","permalink":"http://yoursite.com/tags/书籍/"},{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"}]},{"title":"《这样写出好故事》笔记","slug":"这样写出好故事笔记","date":"2021-01-15T09:17:35.000Z","updated":"2022-11-25T06:28:53.839Z","comments":true,"path":"2021/01/15/这样写出好故事笔记/","link":"","permalink":"http://yoursite.com/2021/01/15/这样写出好故事笔记/","excerpt":"","text":"概要书名：《这样写出好故事》作者：[美]詹姆斯·斯科特·贝尔。译者：苏雅薇 作者以他的写作经验写了一本写作指导书，详实的描述了如何写一本结构完整、有吸引力的商业小说。完成了如何想出好的写作点子、如何编排情节、如何吸引读者的手把手教学。 本部分是我的读书笔记。《这样写出好故事》练习题 写作这件事儿如何开始写作？你告诉自己，我想要写作。但是你有没有在脑海中形成一个清晰的想法：你想要写什么？你想要的写一个故事，一个什么样的故事？你为什么想要写这个故事？你想借由这个故事表达什么？ 对于写作的建议 找出哪些活动能让你文思泉涌，不要浪费机会，每次都要把涌现的灵感转化为稿本上的文字。 深度消化书中的内容，融会贯通。多读，多想，多写。 先写，再写好。 持续创作，定下工作量，记录字数产出以及每篇作品的字数。 面向读者 这个故事在讲什么？ 为什么我要读下去？ 有发生什么事吗？ 为什么我要关心这个故事？小说是什么，小说是一个能让读者穿越时空的故事。读者为什么想要读你的故事？他希望从你的小说中获得不一样的人生体验。 好的故事就像人生，只是少了所有无聊的部分。 我要怎么写写作的原则LOCK系统: Lead(主角), Objective(目标), Confrontation(冲突), Knockout(冲击结尾). Lead（主角）稳固的情节永远始于有趣的主角。他不一定要十全十美，但是一定要有特点，能让人记住。 Objective（目标）角色有目标，读者才能知道他能否达成目标。如果主角只是在自己的世界里无所事事，那小说读起来也就索然无味了。目标是小说的动力，驱动故事前进。角色在故事的不同阶段可以有不同的目标，也或者有一个总的目标，每个阶段的目标都是为了实现那个总的目标。生命，权力，爱情，自由，报仇，能力……都可以作为主角的目标。要让读者保持着提心吊胆，就把目标的代价提高。 一些例子：《爱上汤姆的女孩》 斯蒂芬·金《大白鲨》《玫瑰疯狂者》《糖衣陷阱》《沉默的羔羊》《单身公寓》主角想要回到自己快乐的懒虫生活 Confrontation（冲突）好故事永远是一波三折，就像一个好看的走之底。让读者为你的主角担惊受怕，他才能从头到尾投入到小说中，不要让他出戏。在主角前进的路上设满障碍，把事情弄得很复杂，永远不要轻易放过他。主角内心的挣扎也必不可少，如果他从头到尾都没有怀疑过自己的选择，那你该考虑换一个角色了。 Knockout（冲击结尾）要有重击的力道，可以击倒，也可以留给读者想象的空间。 写出不一样的小说文学小说 VS 商业小说文学小说通常步调悠闲，侧重人物的内心世界，如《麦田里的守望者》。商业小说专注于角色身上发生的事情，侧重情节。文学小说比较能接受暧昧不明的情节，而且结局可能令人沮丧。写作的时候需要注意情节的步调。商业小说结尾通常是好人战胜坏人，大快人心。写作的时候需要注意加深对角色的刻画。 专属于你的小说细节LOCK是写作的原则，我们要在这个原则上添加属于自己独特的风味。可以从角色、背景和对话入手。 角色对于角色的刻画，主角固然光彩夺目，但是一个人总没法完成这个故事。你的配角足够有特色吗？ 《红楼梦》狄更斯的小说史蒂芬·金 《末日逼近》 背景生活细节，人物工作独特的细节。多做研究，深入探讨某些职业。如果是老生常谈的职业的话，赋予他们新的挑战和背景设定。力求找出专属于你的独特的元素。 对话每个角色都要有各自的说话方式，角色的遣词造句应该稍微透露他的为人。 选择场景当我们决定要写什么的时候，脑袋里自然而然的会想到一些老梗。所以要训练创意，请试着暂停一下，快速写下一列可能的情节发展，选择最有新意的方向。以此来训练创意。 小说的结构三幕结构：获得信息，进入情节；问题出现，与问题较劲；解决问题。介绍一名角色，他过着特定的生活，然后出现扰乱事件（有事情打乱了现状）。创造一股将主角往前推的力量。人类总是追求安定的，所以我们的小说里，要让环境不允许主角这样做（或者什么都不做）。创造一种避无可避的氛围，把主角丢进主要冲突中，而且无法离开。写作的时候随时问自己：我的主角现在还能忽略情节，继续如先前一般过活吗？ 《教父》《带来奇迹的人》中段陷入与对手的冲突之中，需要某种附着元素（工作/道德义务/实际地点等等）将主角与对手绑在一起。最后主角碰上重大的挫折、危机，或者是发现了新信息和线索，故事无可避免的进入结局。开始——扰乱事件——第一扇无法折返的门（故事的1/5之前）——故事中段——第二扇无法折返的门（故事的3/4之后）——高潮——结局 我要写些什么训练你的创意想情节点子： 审视自己 确定固定的想点子时间，一周至少一次 待在安静的地方，让自己放松 30min不受干扰 把每个点子都记下来 不要设任何限制 评估你的点子想点子的方法： “如果”。你在读别的东西的时候，试着想想，如果不那样，会怎样？如果角色替换，是什么样的结局？然后汇集成表。 书名。先取一个很酷的书名，然后写出相符的作品。诗作、名言、佳句，或者随意的文字组合，或者挑一本小说，用开头第一句来设计书名。 议题。你对什么话题比较关注，哪些话题能让你更有共鸣？逼人发怒的东西？列出你所关心的议题。（环保，噪音，重男轻女，开车玩手机，公共场所吸烟……）注意对正反面的平等对待，哪种人最关心这个议题的正反面？ 亲眼去看。一早坐起来，问自己：“关于现在这个瞬间，我想写些什么？”列出你首先想到的三件事，可能是一个议题、一个角色、或者是一个场景。挑选最能让你文思泉涌的，然后用你的想象力播放一段影片，多久都可以。然后开始动笔，把你记得的都写下来，持续写20分钟，不用管情节结构。每天都写，持续5天，累计你写下来的内容。然后休息一天，把你的电影札记打印出来，翻阅一遍，把你感兴趣的挑出来，开始培养你的点子。 亲耳去听。听一些让你感动的纯音乐，哪些图像、场景会浮现出来？记下来。在以后的创作中也可以播放这首曲子。 角色优先。创造一个立体的角色。 想象外表，描述他的样子。然后把他随便丢进一个场景，看他会怎么选。为什么他会这样做，他展现出什么样的角色特质？ 重塑你认识的人。 网上公众人物，看他们的人物简介，挑出有趣的部分用在你的角色上。年龄性别都无所谓，主要是角色的特质。 最糟的事。你的角色身上能发生的最糟的事情是什么？ 偷别人的情节。改变故事线、角色。 读报纸。（作者建议《今日美国》）。让你的想象力往独创方向跑，扫完一份报纸，找几个新点子。 研究。从你一直感兴趣的领域，挑一本非文学作品，大略翻一遍，了解大意。写下你想到的情节点子。然后把书详细读完，记下更多的点子，同时发展先前想到的点子。 偏执。哪些事物会让人偏执？自尊？外表？欲望？工作？敌人？成功？创造一个角色，让他为某件事而偏执，再看他如何发展。 《悲惨世界》责任心《乱世佳人》爱 写开场白。透露故事的调性。 写序章。紧张刺激的序章能带出更多的好点子。 联想图。从某个词会联想到什么事情？任其发挥，画在纸上。 感动人心的结尾。 在脑海中的剧院想象一场高潮结尾 倾听搭配的音乐 让各式各样的情绪涌现 加入角色，增加冲突 尝试以不同的方式呈现同一个主题 故事中有哪些角色 什么事情让他们聚在一起 如何回溯到这个故事合理的起点 职业。以吸引人的工作为基础，想出一些故事点子。（参考职业相关的百科全书，美国有《职衔大辞典》）阅读职业介绍，并确定你要针对哪个领域继续研究。 绝望。如果你的脑子里空空如也，那就对着你的白纸或空白文档瞎写，想到什么写什么。 培养你的点子挑出你最喜欢的点子，写出它的诱因、标语和弱点。诱因：小说主题。迪恩·孔茨《午夜》写了滥用生物科技祸及整个小镇的故事。你的小说想些什么？标语：用一两句话，为你的点子写宣传。 迪恩·孔茨《冬夜》洛杉矶的大街成了末日炼狱。在蒙达加州寂寥的角落，神秘的存在侵入森林。随着这些事件交错并逐渐失控，活人和死人都无法幸免。 弱点：反向思考，什么事情可能毁掉你的点子？ 这个点子以前有人用过吗？你能想出什么独特的元素？ 你的设定普通吗？你能把故事改设在什么场景？ 你的角色脸谱化严重吗？怎么把他们变得有趣？你能提供什么新的切入点？ 可以吸引足够的读者吗？如何扩大规模？你能怎么提高主角面临的代价？ 从各个角度来思考你的点子，并思考能否加入一两个转折，让整个故事更有活力。 最后的忠告 对你即将要写的小说饱含热情 思考这个主题能触及多少读者。（订阅《出版人周刊》（《Publishers Weekly》）追踪业内的最新动向，为什么出版社看上这些故事？） 精准的目标。定位精准，删掉其他所有影响主题的东西。 强劲的开头 目标 吸引读者； 建立读者与主角之间的联结； 介绍故事中的世界，地点时代等相关背景； 奠定小说基本的调性，让读者知道这是一本什么样的小说，步调如何； 说服读者继续读到中段，为什么读者要关心你的故事，继续读下去? 介绍对手出场，有哪些人物想要阻挡主角? 吸引读者开场白 包含了角色的名称 她听到卧房有东西在动麦迪端详着晨光，躺在床上她先生应该睡的那一侧 带给读者动感，暗示有事情已经发生或者即将发生，让读者一开始就感觉到情节的移动。传达出有事发生的感觉。 七月中的一个周六早晨，简·施里奇曼律师在早上八点半被电话吵醒 序章通常序章都绕着不是主角的角色打转，但是要和主线情节连接起来。主线情节从第一章开始，而序章发生的事件会笼罩在整个故事上。 动作场景序章 动作场景规模要足够大，足以撑满一整篇序章 不要写太长 以麻烦问题作结，坏事即将发生或已经发生 注意与主线情节的联结 外框故事带出角色，让他准备回首讲述这个故事。营造特殊氛围，仿佛接下来发生的事影响之大甚至波及了现在和未来。通过外框故事，我们可以: 用于奠定想要笼罩主线情节的情绪和风格，但是序章本身必须值得一读，不能只是枯燥的叙述。 让读者知道，即将发生的事如何到了现在还持续影响序章中的角色。 通过主角，建立与读者的联结认同让读者对主角产生认同感，让读者认为主角和自己类似，在特定情况下我们也会跟主角陷入同样的处境，并做出类似的反应。给你的主角赋予真人的特性，一般来讲： 希望能成大事 有时候有点胆小 并不完美你的主角该如何行动思考，才能像一般人?让读者亲近你的主角。 同情同情能加强读者对主角的情感投入。《飘》里面的斯嘉丽刚出场时满满的负面特质，还做了一些很蠢的事情，但是作者通过写作手法和她之后的遭遇，让人对她有同情有钦佩。写作的时候要想办法激起读者的同情。 危机。实际的危险或心理层面的危机。 困难。让他面对不是自己造成的苦难，但是不能让主角一直抱怨他遭遇的困难（可以偶尔发泄情绪），因为读者欣赏努力克服困难的人。 弱者，美国人喜欢面对巨大挑战的人，中国人喜欢以弱胜强或者打怪升级。 脆弱。如果感觉主角随时都有可能被击倒，读者便会替他担心。不一定是悬疑才有令人紧张的情节。《飘》中斯嘉丽的走投无路；《穿过森林的男孩》里边主角面临的谜团以及后边的绝望无助。 喜爱惹人喜爱的主角通常会做讨人喜欢的事。乐于助人、很会说话、个性积极，你喜欢什么样的人？把他们的一些特质加到主角身上。列一下有哪些特性。幽默又不自傲，等等。如果是个不讨喜的角色，需要有一些吸引人的特性。 内心冲突角色如果对自己的决定毫不怀疑，总能毫无恐惧，勇往直前，那就不有趣了。每个人都有疑虑，将主角的疑虑摊在情节表面，带动读者一起去考虑。 呈现故事里的世界你的主角住在什么样的世界里？主角过着什么样的生活？ 奠定风格一本小说带给读者的整体印象风格应该一致。 好小说应该始于某人对威胁的反应，并描写他如何应对。 说服读者继续读到中段确保对手至少跟主角一样强，甚至更强。给对手反抗主角的正当理由，替他辩护，你的小说结构会因此更扎实。如果你要以第一人称视角写作，请赋予主角能吸引读者的声音。如果以描述段落开场，要达成三个目标： 奠定故事氛围 尽早加入角色 给读者继续读下去的理由请记住所有风景的描述都是为了营造气氛，或推动故事情节或表达主角心情（《飘》中对风景的描述）。 《白夹竹桃》开头圣塔安娜的风从炎热的沙漠吹来，使最后一抹春天的绿草也枯萎成稀疏的干稻草。只有夹竹桃还屹立不倒，绽放着精巧有毒的花朵伸展着尖如匕首的绿叶。 即使以描述开场，也要马上进入扰乱场景。 处理说明段落（作者认为读者需要知道的信息） 先有动作，再解释。随着故事发展，才在必要时分批丢一点信息出来。 模仿冰山。只说出10%，千万不要一次性都说出来。 将信息包装在冲突中。呈现信息的最好时机是气氛紧张的冲突场景，通过角色的想法和对话，将重要信息丢到读者眼前。 介绍对手出场反派形象的塑造：在令人恐惧的同时，也要让人觉得可怜。要从对手的角度来解释他的所作所为。他有哪些吸引人的特质？ 中段中段主要目标：用场景延续紧张情绪，提高角色面对的代价，让读者一直担心。 死亡让死亡的阴影从头到尾笼罩在主角头上，包括精神上的和职业生涯的死亡。读者担心主角会失去些什么。想要的东西，与主角的命运息息相关。 对手对手要有足够的理由阻止主角。站在对手的立场去思考。对对手的塑造参考意见： 将对手设定为人。 如果对手是一群人，挑一个领袖。 让对手比主角强。 附着元素把对手和主角捆绑在一起，避无可避。要有足够的理由形成冲突。写下数个冲突场景，大部分都以主角遭逢挫败作结，借此强迫他重新分析处境，采取其他方法达成目标。把故事漫长的中段当做一系列越来越激烈的战斗。一来一往，闪躲后又进击。附着元素参考： 生与死。如果对手有足够的理由杀死主角，自然就会产生附着元素。 职责。 道德义务。 偏执。 故事发生的地点。 准备好冲突用的武器“行动、反应、继续行动”，角色为了达成渴望的目标，通过行动解决眼前问题。先写出行动，然后提出合理的解释。 吸引读者读下去 拉长紧张段落。 提高角色要付出的代价。 拉长紧张段落确定紧张场景真的有理由让人紧张，替角色找好他要面对的麻烦，实际和心理层面的麻烦。拉长实际遭遇危险和悬疑的段落。放慢动作，在脑海中一格一格过这个场景。开始动笔时，交替使用动作、内心戏、对话和叙述，每一类都花时间好好描写，注意细节。安排场景的节奏，以符合故事应有的风格和感觉。拉长心理的紧张段落——角色陷入痛苦的情感纠葛。初稿要尽量拉长紧张段落，后面如果不需要可以调控。 提高角色要付出的代价创造一个值得关注的角色以及一个必须解决的问题，并在过程中提高主角要付出的代价。想想最糟糕的事情是什么，角色最畏惧的是什么，最糟的消息是什么？需要知道的是先要替读者奠定足够的感情基础，让读者在乎你的主角。替主角想出更严峻的困境。列出笔下角色可能碰上的麻烦，依照问题的严重程度，从轻微到严重排列。建立代价概要，用来建立小说的场景和转折点。 情节造成的代价 我的主角会遭遇哪些实际伤害？我能把这个威胁推展到什么程度？ 哪些新势力会对抗主角？我能加入哪些角色，把状况弄得更糟？这些外来势力如何运作，他们会运用哪些技巧？ 主角需要付出职责上的代价吗？他的职业生涯能发生什么最糟的状况？ 角色内心的代价 怎么样才能使我的主角情绪更为纠结？ 主角在乎的人有没有办法陷入麻烦？ 主角有没有见不得人的秘密可以揭露？ 社会造成的代价 你的故事中，与角色紧密相关的社会状况如何？ 你的角色需要面对什么重大社会问题吗？ 社会冲突的两方可以安插哪些角色？ 如何唤醒昏昏欲睡的中段 分析故事中的代价。 加强附着元素。 提高情节的复杂程度。 增加新角色，让主角的日子更难过。来自主角过去生活环境的意外角色，而且握着主角想要隐藏的秘密。或者表面上支持主角，但经常帮倒忙。或者恋爱对象。 增加新的副线情节。要显得自然且和主线情节相关。 继续写，直到写完初稿。 如何删减过于庞大的中段 合并或删掉角色。 合并副线情节。把沉闷的副线情节的精华集结起来，合并成更强而有力的主线情节。 削减无聊程度。主要注意场景冲突和紧张感。这个场景你从头到尾都觉得有趣吗？ 结尾 结局给读者的感觉需要完全符合这本小说所属的类型。 要让读者感到惊讶，不会给人以似曾相识的感觉。 冲击结尾尽可能将情节的紧绷情绪拖到最后一刻。 带出“真好”或“糟了”的感受“真好”：你的结局可以让读者感觉到希望，结局圆满。“糟了”：一般恐怖电影经常用的，到最后一刻，用某个小细节透露出故事并没有就这样结束的感觉。 选择结尾 正向结局 模糊结局 负向结局 好的模糊结局必须带给读者强烈的感受，而且感觉合理，还能激起讨论。以这三种基本结局为基础，加入一些其他的元素——比如主角达成了目标，却导致了负向的结果，或者反一下，主角没有达成目标，却导致了正向的结果——可以增加结局的复杂度。《卡萨布兰卡》中瑞克为了更远大的理想，放弃了自己一直渴望的目标。在复杂的结局中，主角可能执意达成目标，但是会付出道德上的代价。或者做正确的选择，放弃最重要的目标，失去他从小说开头就一直渴望着的事物。 意外结局让结局既在意料之外，又在情理之中。通过练习替结局想出可能的转折。快写完初稿时，花30分钟头脑风暴，想出10个不同的结局。天马行空，越快越好，别坚持每个结局都要有道理。审视你的答案，列出前4名，稍微加工，再选出最适合当转折的结局。思考如何将这段情节加入原本的结局。回头检视你的小说，四处埋一些小线索，让你的转折结尾变得合理。 收掉四散的梗如果这个梗很重要，加入一个主要场景。而小的梗可以让角色解释后来怎么了。 不要急着结束要避免因为疲惫而匆匆写完结局。建议： 记录你的梦境。早上起床后把梦境记录下来，集合成梦境日记，从你的梦里寻找灵感。 把规模放大。在改稿的时候再删减结尾规模。 不要着急。 场景场景是建构小说的单位。 如果你将几个场景串起来，场景之间似乎有关联，就表示你会写小说了。 有读者关心的角色，做读者非看不可的事情，靠紧张情绪和原创性赋予场景活力。尽力写好一个场景，隔一阵子再回来看看，改掉无聊的部分，尝试新的写法。 场景的四个和弦行动场景（主要和弦）角色做事以达成主要目标时，就会产生行动。角色有场景内的目标，场景目标通常让读者更接近整个故事的目标。场景需要有冲突。 反应场景（主要和弦）反应场景描写描写主角碰上事情时，他情绪上如何反应。主要描写的是主角的内心世界。文学小说里多一些。可以将反应桥段放在行动场景的中间，让读者了解角色的感受。角色作出行动，然后因为冲突而受挫，在他对当下的形势仔细思考后，决定下一项行动。 铺陈场景（辅助，数量应该压到最低）铺陈场景存在是为了让随后的场景显得合理，每本小说都需要一定程度的铺陈。在铺陈场景丢入一个问题，不必在乎问题大小，也许只是角色感到焦虑或与人争执，但也可以是必须立即处理的大问题。这样可以让铺陈场景显得不那么无聊。 深化场景（辅助）通常不会独立成一个场景，而是融入其他场景，加深读者对角色或设定的了解。 场景需要的其他元素引子引子负责从头吸引读者的注意，将他拉进故事的世界里。 以问句开始场景，让读者想知道主角会怎么回答，接着介绍地点，然后又回到动作上。 以预告作为引子，隐晦地告知读者紧张的场景即将到来。 行动、叙述等等。不论用什么作为引子，需要达成的效果是吸引读者的注意。尝试不同的段落开始，改变方法，轮流使用对话、行动、叙述和预告，找到适合的引子。 紧张程度使用冲突替场景注入紧张感。你的小说主线情节应该有无限冲突的可能，就连同伴之间的场景也应该有点紧张，否则只是交换情报，非常无聊。除了事件本身带来的的紧张感，我们还应该呈现角色的担心和焦虑，创造一些情绪上的紧张感。如果场景的紧张程度不够，请考虑删除这个场景。 推手以推手替场景做结，让读者继续读下去。常用的推手有： 一句神秘的对话。 突然揭露的秘密。 重大的决定或誓言。 公开撼动情节的事件。 逆转或意外——让故事急转弯的新消息。 尚未解答的问题。如果场景感觉结束的太赶，可以砍掉最后一两段，并非每个场景都需要写到合理的结尾为止，激起兴趣，创造未完的悬念。 紧张程度表（展示vs说明） 展示：一听到“艾比”两个字，泪水马上涌上凯伦的眼眶，一直藏在心底的恐慌扑上表面，让她在原地动弹不得。她的下巴开始颤动，她试着尖叫，但喉咙一点声音都发不出来。 对于紧张的场景，通过凯伦的生理反应，展示给读者看她的感受，让读者直接体会她的情绪。 说明：艾比拍拍手，突然大笑起来。凯伦唱歌唱得有些喘，她伸手在手机输入一串号码。关于她在机场对威尔讲话的态度，她感到有些不好意思。 对于不那么紧张的段落，只需要告诉读者，她“不好意思”就可以了。 小说通常有几个重大场景，在大场景之间插入紧张程度不一的场景来调整布局。先决定你的小说有哪些章节或场景不可或缺。从0~10评估你写的每个场景，0是毫不紧张时，10是紧张过头。制作你的紧张程度表，利用紧张程度表取得平衡，不能一直让读者处于同一种情绪。10：只有一两个场景需要达到这个程度，小心使用。9~8：必备转折大场景。7~6：冲突，重要的情绪，尖锐的对话，内心的煎熬。5：适合由此开始场景，然后再慢慢往上升。4~3：铺陈及其他过渡场景。要短。2~1：最好不要，如果从此处开始，需要尽快往上爬。0：删除。 长篇分解练习// TODO地点 目标 冲突对象 推手爱尔兰 离开爱尔兰 父亲、邻居 打伤父亲后离家 复杂的情节发展主旨规划情节时，问问自己读者希望从你的作品中学到什么东西。用一行写出答案，这就是你的小说主旨。一本小说应该只有一个隐藏信息，不过其中可以包含很多小信息。角色负责承载主旨。先发展好你的角色，再将它们放入情节的世界里，让角色间的价值观相互冲撞。若角色能自然又热情的挣扎，这时故事的主旨就会不费吹灰之力地出现了。 副线情节带出主旨的副线情节，传达隐藏信息，为故事增添了深度和意义。借此倡导生命中重要的事物。 象征和主题象征指的是意象，一个代表着其他事物的东西；主题是不断重复的画面或词汇。 《末路记事》中，鲸鱼成为希望的象征。《白夹竹桃》中，顽强、诱人又有毒的夹竹桃代表母亲，即使在狱中也试图控制她。“挣扎想照到一点光”的西红柿，象征阿斯特丽德本人。 先写下富含感官细节的场景，再仔细研究你写的内容，找到一个东西，作为不断重复的意象。 长篇小说分段，每段都遵循LOCK原则。比如《雷蒙斯尼奇的不幸历险》。 平行情节几条情节线同时进行，不同线的情节逐渐交错，最后结合在一起，带来震撼人心的高潮结局。如东野圭吾的《梦幻花》，由黄色牵牛花串起一群人。每条情节线都要有意义。 玩弄结构和风格以增添复杂性非线性叙事。《公民凯恩》中，主角查尔斯的生平故事由多位认识他的角色倒叙回想拼凑起来，因此情节在他人生的不同阶段跳来跳去，但每段回忆都让观众进一步窥见故事的全貌。 情节中的角色弧线角色的成长可以增添情节的深度。故事令人难忘的原因不是其中发生的事件，而是事件对角色的影响。 角色弧线角色弧线描述整个故事过程中角色的内心发展，角色在经历了这些事情之后的成长。想想你的角色深信的主要理念，设计几个事件，教会他新的人生教诲。 狄更斯 《圣诞颂歌》 用外界压力去影响角色的看法，再由他的看法改变到主导态度的改变，从主导态度到价值观，价值观到核心理念，核心理念改变自我形象。要避免把角色的转变写得太明了。 起始点，介绍角色出场，让读者了解它的内在层次。 设计影响事件。 加深影响的扰乱事件，刻画角色改变的瞬间。 事件的后果。 角色弧线表做一张表记录角色转变，涵盖故事中的主要桥段。每个关键时刻都能描述角色的内心世界。角色开始如何？结尾变得怎么样？中间遇到了什么外界压力使它发生了改变？// TODO 表格犯罪，羁押，审判及判刑，牢中。无怜悯心，愤世嫉俗中间遇见了什么事，什么人，使他发生了什么改变？以什么方式反映他的改变？发现世上需要同情心。 情节编排手法 LOCK系统 写好封底文案——说服读者买书的营销文案，在封底文案中加入情节元素，小说的轮廓便会越来越明显。反复推敲这段文字，直到你自己读了都兴奋不已。 不大纲人的方法 定下写作目标，最好每天都写。每次写作时完成当天的写作目标前都不应该离开书桌，有灵感了就多写一点，自行判断最适合你的字数。以及，可以尝试一早起来写作。 每次先读前一天写的内容，不需要做重大改变，只需要解决小问题或增加一些内容。读前一天的内容时，如果有想加的，在旁边圈圈备注从a开始。动笔时，先从要加的部分开始写，新的角色、新的情节等等。 每周花一天记录情节走向。使用情节表格记录一下你写了什么，故事中的日期和时间。 大纲人的方法索引卡系统 初始阶段。记下你的场景点子，不用担心结构。 先想结尾。积累了很多场景点子，处理好了LOCK元素，写好了封底文案，此时想想故事的结局。把想法写在索引卡上，越详细越好，这样可以让你有明确的写作方向。 主要场景。开头、扰乱事件和两扇无法折返的门组成了4个主要场景。尽可能给这4个主要场景添加细节，写在索引卡上，但是不要花太多时间。 布局。排列索引卡，开头场景的索引卡放在左边，高潮结尾往右，填满情节。越靠近最后一张卡，场景越紧绷。如果场景之间出现空隙，放几张空白索引卡，通过布局试着感受一下故事的节奏。 玩一下索引卡，需要增加或者删除都行。如果多主角或者多条副线情节，可以用不同颜色区分，将不同颜色的索引卡排列好，让每条情节线互相平行呈现，或者是情节线和角色心路历程线平行呈现。 大致确定场景顺序后给索引卡编号，然后打乱。两张两张看，情节之间有没有什么联系？ 动笔写。每写3、4个场景，就把索引卡重新排列一次，看有没有新的发现或者新的想法。如果需要，可以写新的索引卡，更改排列顺序，增加原本的内容。 头灯系统边写作边定大纲，知道大致流程，写好封底文案、开头和结尾。 这个场景结尾时角色的情绪状况如何？他在下个场景会如何反应？ 我的角色接下来需要采取什么行动？ 接下来有哪个重要场景需要先用转折场景铺陈? 我需要加入新角色吗？刚写完的场景中，有哪个角色暗示了其他情节发展？ 叙事大纲简明扼要地写完你的故事。 戴维·默莱尔方法深入故事点子，了解你为什么想写这个故事。写一封信给自己，问自己有关情节点子的问题。为什么写这个故事？理由只有这样吗？他的旅途目的是什么？女儿为什么这么重要？他为什么这么依赖麦迪？还有别的原因吗？可以在写作过程中每天多写一点，自问自答。加深你对故事题材的了解。 博格人大纲把你的小说当做你要开发的一个软件，对它进行需求分析、概要设计、详细设计和编码，最后细修所有细节。 定义LOCK元素。 撰写封底文案。 列出小说的整体结构，三幕和两扇门。 雕琢你的角色，建立角色表格，记下所有角色的相关信息。// TODO 角色表格姓名，外表描述，身份，目标和动机，秘密，激起的情绪。 每幕摘要，大致描述每一幕写了啥 每一章的单句摘要。注意定下合理的时限。 每一章的完整摘要。拉长成每个场景的短摘要，时间、地点、相关角色都记下来。 休息一下 动笔写小说。如果写到你认为需要脱离大纲了，请修改大纲，重复上述步骤。 修改你的小说 修改你的情节写出初稿先写出初稿，一直写。按照前面的方法，一路写到结尾。可以在继续往下写之前修订前一天的内容，但请抗拒修改更多的冲动。 沉淀一下忘了你的小说，去做点别的事情。两三周后开始改这篇稿子。 做好心理准备要让自己对改稿兴奋起来。 按照计划改稿，会让我的小说更稳健。 依照计划改稿很好玩，因为我知道每一步该怎么做。 改稿才能分出真正的专家和自我感觉良好的门外汉的差异。 我想成为专家。 读一遍你的初稿将印出来的初稿带到安静的地方读一遍，尽快读完。别太在意细节，只注意故事全貌和整体感觉，可以写简短的笔记，但不要停下来太长时间。读初稿可用的方法： 打勾表示我觉得这页的情节太拖沓。 用括号括住我看不懂的句子。 在页面边缘画圈，表示我觉得这段需要增加内容。 画问号表示我认为这段可能需要删减。 先从大问题着手，再考虑小细节。 我想讲什么样的故事？分析你的故事并自问下列问题： 读初稿的时候，有哪些地方让你感到惊讶吗？你觉得原因是什么？其中有你想进一步发展的元素吗？ 角色到底在故事里做什么？他们身上还有尚未完全探讨的议题吗？ 检视拖戏的段落，因为你可能在这些段落逃避处理更深层的议题。这些时候角色到底在想什么？他们当下的兴趣、挫折与欲望是什么？ 想象另一条情节线，如果在故事中的几个时点让情节转了弯，你的故事会有何不同？你未必要照着岔路走，但这些旁枝或许有些元素可以导入主线情节。如果你对上述问题的答案有所共鸣，请试着替你的情节写一份摘要，但加入上述问题建议的额外元素。写出两三页的情节纲要，再修改纲要，加入新的想法、角色和主题，越修改，你就越接近真正想说的故事。 故事结构。 你的故事自然以三幕呈现吗？ 主角的世界有马上遭到扰乱吗？ 第1扇无法折返的门出现在故事开始1/5之前吗？ 主角面临的代价够高吗？ 第2扇无法折返的门有带领主角走向高潮结尾吗？ 故事节奏符合你的打算吗？如果你写的是动作小说，情节有不断前进吗？如果是角色导向的小说，每个场景的深度够吗？ 角色有明确的强烈动机吗？ 所有巧合都有先铺陈吗？ 小说一开始就有事件发生吗？你有在场景中丢入问题并放入角色让他面对改变或威胁吗？ 时间线合理吗？ 情节发展是否太容易预测了？场景顺序是否需要重新调整？ 关于主角 主角令人印象深刻吗？引人注意吗？能带领读者一路走到结尾吗？主角必须仿佛从纸面上活过来，你的主角是这样吗？ 主角有避开老梗设定吗？他能让读者感到惊讶吗？她有什么特别？ 主角的目标够重要吗？ 随着故事发展，主角如何成长？ 主角如何展现内在力量？ 关于对手 对手角色有趣吗？ 它的设定完整，不只是样板角色吗？ 他的行为（至少在他心中）合理吗？ 他至少跟主角一样强，或比主角更强吗？ 关于情节附着元素 主角和对手之间的冲突对双方都非常必要吗？ 为什么他们不能放手离开？哪些元素将他们绑在一起？ 关于场景 重大场景的规模够大吗？让人吃惊吗？你可以把这些场景发挥到极致，写的更独创、更难以预测吗？ 场景中的冲突够吗？ 哪个场景最不起眼？把他删了，于是你有了新的最不起眼场景，请考虑也把他删了。 为了让故事不断前进，你还可以删掉什么？ 高潮场景是否来的太早（因为你写累了）？你能将高潮场景发挥到极致，写得更精彩吗？设下定时炸弹，让读者紧张不已。 你需要新的小副线情节，来支撑拖戏的中段吗？ 关于配角 他们在剧中的目的是什么？ 这些角色独特又生动吗？ 沉思你写了什么花5~7天，四处走走，想想你的初稿。每天醒来写点和小说有关的笔记，然后读所有的笔记最后一次。 写第2份稿大幅度重写你的故事。 精炼把稿子放一放，放一周，以全新的观点读一遍，缩减或删除场景，加深角色内涵，加长或修改副线情节。精炼情节，让角色、情节、场景和主旨完全按照你要的方式呈现。“杀掉你的最爱”，对于你最喜欢的话，想一下它是有助于情节，还是会让读者暂时出戏。 润饰重新审视稿子，先读一遍，专注在场景上，并自问一下问题： 你一开始就勾起了读者的兴趣吗？ 悬疑场景是否拉的够长，将紧张感推到极点？ 哪些信息可以晚点再揭露？这样读者会越读越紧张，保证有利无害。 故事中的惊喜够多吗？ 角色反应场景是否既有深度又有趣？ 检查章节结尾的“继续读推手”。 哪些地方可以用行动取代角色感受的描述？ 你有使用诉诸视觉、刺激感官的字眼吗？（展示场景）接着再读一遍，这次专注在对话上。 只要删掉句中几个字，通常就能加强对话。 写对话时，请不要偏心。别把好对话都派给同一个角色。 好的对话能创造紧张情绪，别让读者感到惊讶。将对话当做一场游戏，参赛者都亟于赢过对方。 即使是同伴之间的对话，你也能增加更多冲突元素吗？ 情节模式了解各个情节模式的结构，结合不同的情节模式去创造全新的情节类型。 远征基本元素 主角在原始世界感到不完整 他寻找的对象一定极为重要 一定有重重难关阻挡主角找到目标 远征旅途最后应该让主角有所改变 结构介绍主角，让读者看到他内心的不足，而远征旅途能补足他的缺憾。第1扇无法折返的门出现在主角踏上远征的时候。系列事件将情节分成明显的篇章。第2扇门通常是重大危机或挫败，或是某种发现或重大线索，将主角带进最后一幕。远征情节模式模拟了每个人的人生旅途。充满挑战，经历挫折或成功，容易撼动人心。 复仇复仇情节模式描述了原始部落民族的生存方式。复仇是一种痛彻心扉的模式，因此情节情绪非常激昂。 基本元素 主角应该值得同情 主角或其近亲通常不是因为犯错而受难，或者犯的错远小于受的难 对于复仇的渴望，会影响主角的内心世界 结构首先介绍主角及原始世界，此时原始世界一定是在一个舒适的状态。紧接着有人受难，主角度过了一定的煎熬期，此时需要加强读者与主角的联结。此时第一扇无法折返的门出现，主角发现是谁陷害他，或者是想到方法如何报复害他的人。主角的目标是复仇，恢复秩序，恢复正义的平衡。发生系列冲突。出现第2扇门，主角和对手走向决战。 爱情基本元素 相爱 有事情拆散他们 排除万难在一起或者永远分离 经历这些之后，其中一人或双方都有所成长 结构男孩遇见女孩，男孩失去女孩，男孩得到女孩。或者遇见，然后交恶，发生系列事情，最后在一起。适合作为副线情节。 冒险 《堂吉诃德》 对于冒险情节模式，要让读者希望他们能跟你的主角一样。 基本元素 和远征不同，冒险情节模式踏上旅途的目的不是寻找某种东西，而是对冒险本身的渴望 沿途会碰上各种有趣的角色和状况 结束冒险后通常会对自己的内心或生活有更深的体悟 结构介绍主角，主角对现在的世界不满，所以出发。主角经历了系列历险，最后走向结局。角色的转变很重要。 追逐 《悲惨世界》、《猫鼠游戏》、《完美的世界》 基本元素 有人需要逃跑 有人在追，处于义务或者是偏执。可以是主角或对手。 你追我跑的形式，往往来自于天大的误解。 结构先要铺陈读者对主角的同情，但主角也需要一些缺点，免得读者过分同情它。在你追我赶的过程中促使主角改变，更了解自己。最后故事结束，胜负已分。 永不妥协 《飞越疯人院》、《正午》、《十二怒汉》 基本元素 主角代表了社群的道德准则 对手比主角强，并对主角的社群产生威胁 主角靠启发其他社群成员而获胜 主角可能靠自我牺牲来启发他人 结构主角以英雄之姿出场，备受景仰。主角的世界遭到对手威胁。主角主动对抗对手。冲突结束，带出结局。 遗世独立 《永不让步》、《卡萨布兰卡》 与永不妥协的情节模式不同的是，遗世独立的情节模式中，主角一心想要归隐，但是被环境所迫，所以不得不有所作为。 基本元素 主角不是英雄，不想与周遭世界挂钩，只想依照自己的道德准则过活 发生了某件事，把它拉入大规模的冲突当中 主角需要决定是否要挺身而出， 是缩回去，还是进入社会。 权力 《教父》 专注于主角的崛起与陨落，或是描述崛起需要付出的道德代价。 基本元素 劣势开局 逐渐崛起 获得权力需要付出道德代价 或者放弃权力，重拾良心 寓言 《动物庄园》George Orwell、《魔戒》托尔金、《纳尼亚传奇》刘易斯、《白鲸记》、《荒野的呼唤》。 寓言情节模式中角色都代表着特定的观念，故事中的事件，则要呈现这些观念造成的影响。 常见的情节问题及解决方法场景太平淡永远要确保场景有张力。每个场景都应该有个中心桥段（热点），聚焦在特定的瞬间或对话。如果场景没有这个热点，或许就该删掉。找到热点，圈起来。重读热点前的段落，画底线，标出非必要的句子。继续往前，删掉场景高点前所有非必要的句子。 倒叙处理不好倒叙容易打断叙事的前进动感。需要考虑： 必要性。如果信息可以在当下的场景中呈现，就不要使用倒叙。 功能。确定倒叙段落能构成完整的场景，紧凑又充满冲突，别只是一股脑丢出资讯。 写法。在开始倒叙时，在当下的场景中，加入一个强烈刺激感官的细节，触动倒叙开始。结束时再将焦点拉回感官刺激。看到什么想到了什么，然后开始倒叙。 小心写。“曾经/当时”这种词语一旦进入倒叙场景就不要再用了。 其他倒叙写法。可以考虑回想，而不是倒叙场景。回想的长度很短，让你可以在当下的场景中丢入有关过去的信息。使用角色的心理活动带给读者信息。 岔路对情节有了另一种思路，与原先的构思相悖。可以继续原先的构思，也可以随手写下接下来几个场景的大纲，看接下来会如何发展。如果故事线比原先的好，可以考虑修改大纲。如果相差太大也可以记录下来备用。 为了情节抵抗角色听到角色的声音，你可以以角色的角度写下自己的随笔，人生信念等。 练习：请闭上眼睛，让角色鲜明的出现在眼前。替他盛装打扮，出席一场社交盛会。在那儿他会碰到一些老朋友，也会碰到他的世界中最有权势的一群人。他打开门，走进宴会。然后发生了什么事？在脑海中观赏这个场景，聆听现场的声音，闻现场的味道，让场景越真实越好。到了某个阶段，找一个人走到主角面前，把饮料泼在他脸上，他如何反应？他周围的人怎么说、怎么做？让场景自行发展，然后带你的角色回家。他跟家里的人或他的狗讲述宴会上发生的事，他的感受如何？请深入探讨他的情绪。在写作的过程中随时可以做这个练习。 陷入苦战 回头。看前几页是否略显枯燥，没有切入重点，你忘了主角的目标，没有任何功能的角色对话？回溯，直至找到感觉不错的段落，自问之后的内容是否可以删掉，并想出比现有内容更好的场景。 跳转。把角色顺着时间线往后挪，移到不同的地点，接触不同的人，让他们面临某些问题。先想出一个吸引人的场景，再思考如何与现在的情节相连，未来场景的元素可以拿来用，中间过程的元素也能纳入到未来场景中。 随便翻阅字典，挑两个字/词连起来，写的东西对小说内容有什么帮助吗？ 脑袋短路 充电。先休息一天，然后按照小说中段的建议突破障碍，你可能会觉得自己写在纸上的每个字都是垃圾，但你要准许自己写烂。先把东西写出来再润饰，这才是写作的黄金准则。 重新体验你的场景。写完一个场景后，回头尝试体验角色的情绪，演出你创造的角色。鲜明地想象场景，加强体验的过程，让事件发生，让角色自由发挥。 想起你的愿景，你的小说到底想表达什么？对于娱乐小说，自问哪些事物让你感动，然后把它们放进小说。以及，你身为作家的愿景是什么？ 关于情节和结构的建议与工具展示和说明小说制胜的黄金准则：只展示，别说明。 达希尔·哈米特的《马耳他之鹰》，将情节描绘得如同荧幕上播放的电影。 我们在写作时需要避开条列式的形容，要看到这些特质通过行为展现在纸面上。 连续剧技巧 不要太快完结事件，通过问问题和延后提供答案，维持过程中读者的兴趣。 如果情节允许，在读者意犹未尽的时候切去另一个场景，再用同样的方式跳离这个场景。 情节笔记 每天开始写作前先写笔记，跟自己对话。——苏·格拉夫顿 雷蒙德·钱特勒之持枪男子绝招假如他写的故事开始拖戏，把一名持枪男子丢入该场景，逼出新的想法与联结。我们在写作时，要学会利用意外元素协助突破当前困境。选择最有创意的意外元素，开始重写。不要马上解释意外的内容，稍后再解释。 第二章大翻转直接砍掉第1章，从第2章开始。稍后必要的时候，再丢入第1章的信息。头一章通常包含太多的解释段落，第2章通常是行动场景，充满动感，吸引读者。 随便挑一本小说，翻到第2章你会感兴趣吗？ 把你的小说前两章颠倒过来 必要时候改新的第1章，让情节维持合理 考虑把原来的第一章完全删掉。 回头检查技巧 凭着热情写完第1幕 把稿子晾几天 重读第1幕，看看你写了什么对你的稿子进行分析：这样够了吗？我还需要什么？我能预期接下来的故事都充满冲突吗？我喜欢主角吗？我会迫不及待想继续写剩下的部分吗？如果不会，为什么？我能更改哪些部分以让我提起兴趣呢？作出决定，然后一口气把剩余的初稿写完。 反预测读者可能认为情节会这样发展，但是我们偏偏不要去这样安排。每次写到主要转折点时，提醒自己列出各种可能发展。可以定大纲时就开始列，或者边写边列。 如何显著改善情节编排技巧投入8~12个星期的时间练习： 挑选6本与你的作品类型相同的小说，不管读过或没读过都可以。 定好这8~12个星期的练习时程表，按表操练。留时间把6本小说先读一遍，接着按照以下的说明，花大约12个小时分析这些作品、做笔记，最后还需要6个多小时来反思。 读第1本书，放轻松去读，并站在读者的角度来看。等你读完，花一天时间想想这本书。你喜欢吗？你觉得感动吗？角色让人印象深刻吗？情节紧凑吗？你觉得有些情节拖沓吗？思考这类问题，并简单记下答案。 用同样的方法把每本书读完。 回到第1本书，这个步骤需要用到索引卡。以场景为单位（一章可能有超过一个场景），在第1张索引卡右上角记下1，这样如果不小心把卡片打散了，还能排回正确的顺序。使用索引卡，记下每个场景的信息：场景设定、叙事角色、两行的场景摘要、场景类型（行动、反应、铺陈、深化等）。场景结尾让你想继续读吗？为什么？ 重复6本。 随便挑一沓索引卡。快速翻阅卡片，阅读所写的信息，想起那个场景，然后换下一张。你几乎等于在脑中快速播放一部电影，用这个方法读完这本小说的情节。重复6本。 挑一沓索引卡，依序排在地上。找出开头、中段、结尾必要的几个桥段，以及构成两扇门的场景。有空的时候也拿其他几本小说的索引卡练习。 反转“来复枪原则” 来复枪原则：如果第1幕开始时，墙上挂了一把来复枪，那剧中某处一定要用到这把枪。 在写作的任何阶段都可以埋梗 水牛奔腾技巧不要去控制你的想象力，放任思绪奔腾，但是要让它们朝着你的目标方向前进。 你的作家笔记本创作小说时，将手边的信息依序整理在作家笔记本里。 情节点子。 角色。关于角色的描述、基本信息、角色的动机。他在故事里希望得到什么？最关心什么？过去有哪些事件在影响他们？这些角色真的想要什么？为什么他们达不到目标？角色的名字：分开列出名和姓，偶尔在报道或在别的地方看见了，需要的时候将它们组合。 研究。搜集相关资料，记下你的研究结果。你的小说需要有什么背景知识？注意细节的刻画。比如某个年代，某一类人穿什么衣服。 情节摘要。每写完一章用一两句话概括摘要内容，然后贴上头一两段和结尾一两段内容（有条件就打印出来归档，没条件就只写概要）。情节摘要用于后期检视你的文章。 问题。问问题能让你想出必要的细节。 情节——这里能发生什么意外事件？ 角色——莱尔需要什么技能，才会做建筑模型？ 研究——美国联合服务组织的女服务员在1943年穿什么衣服？ 基本情节建议推理小说想出你的凶手是谁，动机可能是什么。然后建构出他犯下的复杂谋杀或重案，把案子设计的生动复杂又真实。能在脑中清楚地看到画面，有些作家甚至会画图或制作小布景来呈现场景的样貌。然后思考情节中要丢入哪些线索，要把哪些角色当成嫌犯。 惊悚小说推理小说是读者串联起一条条线索，试图拼凑发生了什么事；而惊悚小说像有把虎头钳逐渐掐紧主角的脖子。剧中的事件越来越紧迫，将主角逼至绝境。故事发展到一个段落，主角必须击败对手。可以从这个场景开始写，尽可能充满创意地建构出主角和对手之间的最终高潮战役。先想好结尾能指引你写作的方向，但也别忘了动机。 文学小说文学小说强调氛围和质感，你希望给读者最后留下什么印象？ 爱情小说目标是撮合恋人，情节绕着目标打转。尽量拆散两人才能制造紧张和挫折感。编排情节时可以想想有多少办法能阻止男女主角在一起，努力加入新鲜的元素。角色背景很适合加入原创内容，你可以赋予角色独一无二的黑暗秘密。 实验性小说尝试新事物，凭着实验冲动写完初稿。可以尝试捕捉睡梦中飘走的点子。 科幻和奇幻小说此类小说适合用来阐述作者的想法。你可以创造一个不存在的世界，来表达你对当今世界的看法。但是不要迷失在自己想象的宏大愿景中，要回归基本，规划好情节。你必须同时努力证明书中世界的规则，又要将这些规则自然的融入情节。在科幻元素之外，还需要赋予主角一段丰富的人生。 撰写你的封底文案填入小说的相关信息主角名称：主角职业：第一扇无法折返的门：对手：为何主角和对手对立？双方面临的代价分别是？主要冲突发生在何处？故事问题是什么？你希望读者的感受是什么样的（毛骨悚然、发人深省或激励人心，等等）？ 随笔写30分钟先别管顺序或遣词用字，只要记住步骤一的每项元素，随笔去写。不要停下来纠正自己，尽情将文字投注到纸面上。 修改开头先写主角的名称和现况，谁是一名什么？他怎么样？用一两句话描述主角的背景以及他所在的世界。以“突然”或“然而”开始，然后填入将主角推进第2幕的主要转折点/第1扇门。用两三句话描述第2幕的内容。以“现在”开始，写一个描写行动的句子，或连续提出几个问题。 茉莉能得到他的遗产吗？还是他会遭到无以名状的致命力量阻挠呢？这些事件会摧毁蒙太鸠家族吗？ 修饰修饰成品，成品字数应该介于250~500字之间（中文五百到一千？）。","categories":[{"name":"书籍","slug":"书籍","permalink":"http://yoursite.com/categories/书籍/"},{"name":"写作","slug":"书籍/写作","permalink":"http://yoursite.com/categories/书籍/写作/"}],"tags":[{"name":"书籍","slug":"书籍","permalink":"http://yoursite.com/tags/书籍/"},{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"},{"name":"写作方法","slug":"写作方法","permalink":"http://yoursite.com/tags/写作方法/"}]},{"title":"《这样写出好故事》练习题","slug":"这样写出好故事练习题","date":"2021-01-14T07:00:05.000Z","updated":"2022-11-25T06:28:53.839Z","comments":true,"path":"2021/01/14/这样写出好故事练习题/","link":"","permalink":"http://yoursite.com/2021/01/14/这样写出好故事练习题/","excerpt":"","text":"概要书名：《这样写出好故事》作者：[美]詹姆斯·斯科特·贝尔。译者：苏雅薇 作者以他的写作经验写了一本写作指导书，详实的描述了如何写一本结构完整、有吸引力的商业小说。完成了如何想出好的写作点子、如何编排情节、如何吸引读者的手把手教学。 本部分收集了每章结束的练习。《这样写出好故事》笔记 所以情节到底是什么——搭建小说的骨架 排定十分钟不受干扰的写作时间。在这段时间内，写一篇短文回答下列问题：读者读我的小说时，我希望他们能感到_______，因为对我来说，小说就是_______。不要多想，发自肺腑地写。写完之后，分析一下你的短文。从中看来，你更喜欢什么样的情节呢？你怀疑情节的重要性吗？你对“虚无缥缈”的文学小说比较有兴趣吗？如果是的话，想想假如你学会一些情节编排技巧，可以替作品增色多少。 拿几本你最喜欢的小说，用LOCK系统分析，研究每项元素在你喜爱的书中如何发挥作用。你可以参考下列问题：·主角为什么吸引你？·主角想要追求或逃离什么？·故事什么时候进入“高潮”？·主角追求目标时，面对的主要障碍是什么？·看完结局你感觉如何？为什么这个结局很棒？ 为你现在想到的点子写下简单的情节。写四句，每句提一个LOCK系统的元素。·我的主角是_______·他的目标是_______·他遭到_______的阻挠，对手阻挠他的原因是_______。·结尾非常冲击，因为_______等你填满空格，你就写出了一本骨架扎实的小说。接下来这本书会协助你把骨架发展成完整的作品。 从你读过的小说中，挑选一系列你喜欢的“调味料”。特别注意：·独特的设定·多层次的角色·铿锵有力的对话·极具影响力的场景当你看到这些元素，请分析它们为什么有用？作者用了哪些技巧？ 结构：稳固你的情节——推动情节发展的事件 分析一些小说或电影，研究这些作品的三幕结构。特别注意： 扰乱事件 两扇无法折返的门 画出你的情节结构简图。想出一件扰乱事件，还有那成为两扇门的事件，把事件摘要写下来，再稍加变化，变成独特又吸引人的桥段。 如何“头脑风暴”情节点子——如何发现好的小说题材 本周挑两个方法来想点子，每个方法至少预留一小时写作时间，好好练习。 从练习一的成果中，挑出你最喜欢的点子。你和你的点子有足够的热情、潜能和精准度，能让你继续写下去吗？ 每个月花几个小时来想点子。随时注意周遭可能出现的点子，勤记笔记，搜集新闻简报。每个月检查一次你的点子，开始培养。 强劲的开头——如何写好故事的开头 重新审视你正在写的小说的第一章。你会使用什么技巧从第一段开始就吸引读者的注意？你有建立动感吗？ 你的故事发生在什么世界？你对这个世界有多了解？你要如何不靠一大段的描述，让读者感受到这个世界的细节？ 你怎么介绍主角出场？你的主角为什么令人难忘？在下面四个类别中，分别替你的主角想出5个答案。 认同。如何让读者对你的主角产生认同感，主角哪些地方“像我们”？ 同情。想想主角的（实质或精神上的）危机、困难、弱者处境和脆弱感。 喜爱。他机智吗？关心别人吗？ 内心冲突。主角脑中有哪两个对立的“声音”？ 主角所在的日常世界遭到什么事物的干扰？哪些改变会造成连带影响？ 给对手反抗主角的正当理由。你要如何从对手的角度，合理解释他的作为？他的过去能解释他现在的为人吗？他有哪些特质很有魅力、吸引人，甚至令人着迷呢？ 中段 决定如果你的主角无法达成目标，会面临哪种实际、心理或职业生涯的死亡。如果你答不上来，先自问主角的目标是否真的密切影响他的命运，然后设法提升目标的重要性，让读者了解为何主角一定要达成目标。 深入描写对手角色，自问“为什么我这么喜欢这个角色？”，你有替他的行为想好合理的解释吗？他有比主角强，或至少跟主角一样强吗？如果没有，请赶快让他变强。 从你的小说中挑一个充满紧张冲突的场景，将情绪最紧绷的段落独立出来。这部分可能有几段或几页，但不论长短，都请试着拉长紧张段落的长度。使用本章建议的每个方法。一两天后，再回来读这个场景，你从头到尾都觉得很有趣吗？必要时你当然可以删掉增加的内容，不过通常你会发现这样一改，反而增添了阅读的乐趣。 你的小说中，角色要付出哪些代价？请考虑每个层面——情节、角色和社会，并把没有用到的类型加入故事中。同时想想在情节发展的过程中，你能如何把每种代价提升到极限。 重读一本你觉得失败的小说。把自己当做编辑，依照本章的内容，寻找可以改进的地方。接着写一封信给作者，建议他可以做哪些改变。不用真的寄出去。 结尾 重读你最喜欢的小说最后几章，并分析每个结局。结局明确吗？结果正向还是负面？有没有意外转折？为什么你觉得这个结局好？如此分析能协助你了解自己的写作偏好。 你为你的小说想了什么结局？试着写下结尾的高潮场景。最终你未必要用这个场景，但这个联系能促使你思考结局，让你更加深入了解角色。可以将得到的信息运用在作品中。 想出两三种替代结局。首先列出十种可能，每种各写一行。接着挑出两三个最有潜力的选项，写出结尾场景摘要（500字以内）。如果替代结尾感觉比原先的版本更有冲击，那就用吧。把原本的结局当做最后可能的转折，或者保留原先的结局，将替代结局之一当成可能的转折。 列出你的小说中所有没收好的梗。可以边写边做，每次埋梗时，在另一个档案里做记录。想好策略，利用情节发展、配角或报纸报道把这些四散的梗收好。 场景 从书柜上随便拿起一本小说，翻开一个场景开始读。请分析： 这是行动场景吗？找出你在何处得知角色在这个场景的目标，以及他面临的冲突。场景如何结束？你会想继续读吗？为什么？ 这主要是反应场景吗？角色感到了什么情绪？作者如何展现角色的情绪？场景结束时，角色决定要怎么办了吗？角色有所转变吗？变得坚强，还是软弱？ 找一个行动场景，使用紧张程度表，画出场景的紧张程度。 检视你写的一个章节，分析其中的引子、紧张程度和结尾推手。你能如何把每一项写得更好？ 复杂的情节 在纸上画三栏。第一栏记下场景中突出的丰富细节，第二栏列出主要角色，最后一栏记录重要的地点。接着开始寻找每一栏之间的联结，将某项细节跟角色和地点连在一起，或者倒过来，从地点去联想角色和细节。挑出最强的两三组联结，试着融入情节中，当做象征或主题。 决定你的小说要讲述的主旨价值，用一句话写出来。在编写情节的任何阶段都可以做这项练习，如果你很早就想好，那发展场景时可别忘了。千万注意别显得太刻意，你的信息一定要自然呈现。 听音乐也是替小说想画面的良方。先放松，深呼吸，然后播放让你感动的音乐，可能是电影配乐、古典音乐或爵士。不要选有歌词的曲子。沉浸在隐约之中，闭上眼睛，让画面甚至是场景自动出现在你的想象当中。然后停下来，把想到的画面场景记在纸上或计算机上。写作过程中，你可以不时重复这项练习。 情节中的角色弧线 从你喜欢的小说中，挑一本主角发生重大转变的作品来分析。《圣诞颂歌》就是经典范例。以双线标出主角生命中受到严重挑战的段落，然后在上述事件影响角色转变的段落打钩。 写一段小说简介，描述你的主角在故事刚开始时的个性。请描述他的： 理念 价值观 主要态度 看法接着问问自己，情节中会发生什么事，能改变或挑战主角的上述特质？ 制作你的角色弧线表。在第一列填入改变角色内心世界的主要事件，下方的空格则描述角色发生了什么事。 修改你的情节 为了体验改稿的过程，请将你正在写的两三章打印出来。读一遍，在页缘画下下列记号： 如果你觉得情节拖沓，就打个钩。 用括号标出看不懂的句子。 你觉得某一段可能需要增加内容，就在边边画个圈。也许你想拉长紧张感，或者让情节别那么断断续续。 你觉得某一段可能需要删减，就画个问号。这段可能是过长的解释场景，或者你“说明”太多却没有“展示”。 看看你手边档案的章节开头和结尾。每章开头都能马上吸引读者的兴趣吗？每章结尾都有促使读者继续读下去的推手吗？朝这个目标修改。尝试不同的写法，挑选最好的一种。 还有一个办法能让你更习惯改稿：拿练习一的符号去标示你正在读的小说。如果这套改稿方式有的地方你用不惯，请试着思考为什么；如果有的部分你很喜欢，也试着去想为什么。 情节模式 分析几本你最喜欢的小说。你能从每个故事认出一个熟悉的情节模式，还是几个模式的综合体呢？ 分析你选的小说结构，写下每一幕发生的事。 选择本章其中一个模式，以此为本写出新情节。这时还不用考虑原创性，只要使用你想到的角色，写两三页的叙述。借此感受一下情节模式的结构。 重复练习三，但这次结合两种模式。 常见的情节问题及解决办法 列出你碰到的主要情节问题，请读过你作品的朋友给你一些意见。将最严重的问题摆在前头。利用你从本书和其他地方学到的技巧，确定练习计划，加强你在这些方面的写作能力。 从你的书架或图书馆找出一本你觉得不成功的小说，重读一次，记下到底为什么不成功。你会怎么改进？如果你不确定，请参考写作教学的书，直到找到答案为止。 关于情节和结构的建议与工具 挑一个你不熟悉的小说类型，写一段这类小说的情节摘要。这个练习可以加强你的情节编排能力。 随着你学会越多的新技巧，请建立自己的写作工具和技巧档案，尽可能积累记录学到的内容。每隔一阵子，请替你收集的技巧写一句短大纲。这样可以在最短的时间内读完你积累的内容。","categories":[{"name":"书籍","slug":"书籍","permalink":"http://yoursite.com/categories/书籍/"},{"name":"写作","slug":"书籍/写作","permalink":"http://yoursite.com/categories/书籍/写作/"}],"tags":[{"name":"书籍","slug":"书籍","permalink":"http://yoursite.com/tags/书籍/"},{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"},{"name":"写作方法","slug":"写作方法","permalink":"http://yoursite.com/tags/写作方法/"}]},{"title":"Hexo进阶使用指南","slug":"Hexo进阶使用指南","date":"2021-01-09T05:31:57.000Z","updated":"2022-11-25T06:28:53.835Z","comments":true,"path":"2021/01/09/Hexo进阶使用指南/","link":"","permalink":"http://yoursite.com/2021/01/09/Hexo进阶使用指南/","excerpt":"","text":"初步使用1234hexo new title.mdhexo generatehexo serverhexo deploy 分别是新建、更新、预览、同步。 _config.yml文件每个theme会有一个单独的_config.yml文件，用于自定义主题。而你的bolg generator下也会有一个全局的_config.yml文件，用于你自己博客的基础信息配置。可以逐项预览下来，这里只挑一些说。 default_layout默认布局，在blog/_config.yml文件里有设置。有三种布局：post, page, draft。其中draft是草稿，不会主动发布到网站，需要手动执行hexo publish &lt;title&gt;进行发布。要把文章存为草稿的话，从_post文件夹移到_draft文件夹。在本地预览的时候，你可以把render_drafts设置为true，或者是hexo server --draft。page是页面，会给你创建文件夹，以及文件夹目录中自动创建一个index.md文件。blog/source文件夹内的_post和_draft文件夹是存放你的博客文档的，除了设置默认的layout之外，你还可以在创建文件的时候指定hexo new post/draft test。 categories &amp; tags创建完文章之后打开文章，头部一般会有信息1234---title: Hexo进阶使用指南date: 2021-01-09 13:31:57--- 你可以在里边加上categories和tags，下面两种方法都可以。1234categories: - 计算机 - 实用tags: [Hexo, 计算机] 如果你只需要一个tag或者一个category可以像这样：123categories: 计算机tags: - Hexo scaffolds默认模板。你可以在你的blog generator文件夹下找到Scaffold文件，里面存放的是新建文件时的默认模板。你可以在里边添加或修改一些东西。","categories":[{"name":"计算机","slug":"计算机","permalink":"http://yoursite.com/categories/计算机/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"}]},{"title":"浅谈js变量声明","slug":"浅谈js变量声明","date":"2018-04-08T13:25:48.000Z","updated":"2022-11-25T06:28:53.838Z","comments":true,"path":"2018/04/08/浅谈js变量声明/","link":"","permalink":"http://yoursite.com/2018/04/08/浅谈js变量声明/","excerpt":"","text":"&emsp;&emsp;或者确切地说应该是变量声明以及与之相关的一些东西。&emsp;&emsp;这里只谈四种声明方式（var,function,let,const），其它的声明方式以后有接触再更新。 ‘var’ VS ‘let’&emsp;&emsp;var貌似是最常用的，在ES6还没出来的时候只能用var来声明一个变量，var声明的变量只有函数能对其构成作用域。这样的话会出现一些意料之外的问题，比如如果你的页面里有一个元素的id是xxx，那么你在控制台打印出来的就是xxx这个元素本身，但是如果这个id名是parent，那么它打印出来的就是window全局属性。如果你在控制台再输入var parent = document.getElementById(&#39;parent&#39;)，此时console.log得到的结果依然是parent这个元素本身。为什么呢？&emsp;&emsp;全局变量。是的，答案是全局变量。在我们还没有写代码的时候，浏览器就为我们提供了一个全局对象window，window里边的属性我们称之为全局属性。其中parent就是window的一个全局属性，所以在我们还没有写id=parent的时候，parent就已经存在了。所以我们直接调用parent并不能得到那个元素。&emsp;&emsp;但是，你也知道，如果你写了下边这两句话12var a = 10var a = 20 &emsp;&emsp;得到的答案是20，因为变量存在覆盖。所以，在我们重新声明var parent = document.getElementById(&#39;parent&#39;)的时候，实际上是把全局变量window.parent覆盖了。鉴于覆盖全局变量可能会引发另外的问题，所以变量名尽量不要用window的属性。但是window属性那么多——&emsp;&emsp;所以使用局部变量。如果只是在一个小的范围内声明并使用一个变量，那么这个变量在这个区域内把全局属性覆盖了也基本上不会出什么问题。只有函数能构成var的作用域，所以要想使用一个局部变量，我们就需要声明并执行一个函数。这就是立即执行函数。是不是很熟悉？所以说最讨厌这些概念了，明明很简单的东西，非得喊个听上去很牛逼的名词。&emsp;&emsp;鉴于我们写这个函数的目的只是为了造成一个局部作用域，并不需要后边继续进行调用，所以为了提高效率（也为了让你少费脑子想一个函数名），选择直接在声明之后执行它。1234function()&#123; var parent = document.getElementById(&apos;parent&apos;) console.log(parent)&#125;.call() &emsp;&emsp;但是这样子的话并不是万无一失的，在你刷新页面之后会报错，浏览器以为我们的语法错了。避免浏览器报错的方法很多，但是万变不离其宗，不论使用的是什么方法，我们的目的都是让浏览器知道这是一条语句，而不是别的什么。所以这样子给整个函数及其调用方法加一个小括号可以做到。123456( function()&#123; var parent = document.getElementById(&apos;parent&apos;) console.log(parent) &#125;.call()) &emsp;&emsp;或者只在函数声明上加小括号也行。比较通用的是在函数前边加一个运算符，比如说+，-，!（取反），~（二进制取反），告诉浏览器后边的是一个值而不是一个函数声明，让浏览器声明并调用求值。虽然这样得到的函数返回值与原先的结果可能会有偏差（比如用-号的话得到一个负值），但是我们并不需要这个返回值。一开始就说过，这个函数只是用来造一个局部作用域。&emsp;&emsp;你一定会认为这样很麻烦。不过是想要用一个局部变量而已，这样大费周章多少让人心有不甘。所以ES6出了一个let声明方法。&emsp;&emsp;let的作用域在包裹着它的代码块里，也就是说，如果你想要使用一个局部变量，并不需要声明一个立即执行函数，而只需要写一个代码块。上边的代码完全可以变成这个样子1234&#123; let parent = document.getElementById(&apos;parent&apos;) console.log(parent)&#125; &emsp;&emsp;在区域外parent依旧指的是window.parent。这就是let。&emsp;&emsp;此外，关于var还有一个很容易犯的错误，用let就可以完全避免。用js通过父元素为子元素绑定click事件。html如下：123456&lt;div class=&quot;buttons&quot; id=&quot;buttons&quot;&gt; &lt;span&gt;按钮0&lt;/span&gt; &lt;span&gt;按钮1&lt;/span&gt; &lt;span&gt;按钮2&lt;/span&gt; &lt;span&gt;按钮3&lt;/span&gt;&lt;/div&gt; js如下：123456var children = buttons.children //用var声明了一个全局变量children，储存buttons的所有子元素for(var i=0; i&lt;children.length; i++)&#123; children[i].onclick = function()&#123; //执行点击事件的时候输出对应的第几个按钮 console.log(i) &#125;&#125; &emsp;&emsp;我们想要得到的效果是点击按钮0的时候输出0，点击按钮1的时候输出1…但事实上无论你点击什么，输出结果都是4，因为内存里只存了一个i，这个i的最终运算结果是4。但是如果你把var i = 0改成let i = 0就可以得到你想要的结果。因为如果你使用let的话，每次循环引用的都是不同的i（引用了i变量的不同实例），故而能实现你的需求。 变量提升&emsp;&emsp;var和function都有变量提升机制，也就是说，你可以先使用一个变量，然后再声明它。var的变量提升：12console.log(a) //undefinedvar a = 10 &emsp;&emsp;var的变量提升会把声明部分提升到前边。所以上边的代码真正的运行顺序应该是123var aconsole.log(a)a = 10 function的变量提升：12console.log(f) //f()&#123;&#125;function f()&#123;&#125; &emsp;&emsp;function的变量提升会把整个函数提升到前边，所以上边代码的真正运行顺序应该是12function f()&#123;&#125;console.log(f) &emsp;&emsp;我们知道函数还可以用var f = function(){}来声明，这种声明方式的话事实上是12var ff = function()&#123;&#125; &emsp;&emsp;所以变量提升依旧只是提升var f。let没有变量提升&emsp;&emsp;是的，let算是比较正常的了，它不存在变量提升。也就是说，浏览器不会那么贱多此一举地帮你改变代码的顺序。但是这样的话就会出现“暂时性死区（temporal dead zone）”，如果你用let在一个作用域内声明了一个变量，那么在这个作用域内，let声明之前，这个变量是不可以被使用的，会报错。但是由于js可以有非声明变量（不使用任何声明语句直接对一个变量进行操作），所以这就会出现一个很奇怪（发现自己写js相关blog的时候用“奇怪”的频率好高。。。）的现象。1234typeof a //error: a is not defineda = 20 //error: a is not definedtypeof a //error: a is not definedlet a = 10 &emsp;&emsp;但是上述代码如果把let a = 10删掉就会是这样的结果。123typeof a //&quot;undefined&quot;a = 20 //不报错，正常赋值typeof a //&quot;number&quot; &emsp;&emsp;除了暂时性死区之外，还需要注意的一点是let声明的变量不可重复声明。在同一个代码块内，如果你用let声明了一个变量a，那你就不能再继续用任何声明方法（包括let，var和function）来声明a变量。 const声明常量&emsp;&emsp;使用const声明的变量往往是一个常量，但是这个常量只是说它们在栈内存中存储的东西不变，对于复杂类型（object）而言，const意味着这个变量里边存的地址不会改变，但是地址里边的东西其实是可变的。除此之外，const的特性与let基本相同。两者同是ES6新增的命令。12345678const N = 10 //常量一般用全大写字母表示N = 20 //errorconst OBJ = &#123; &apos;a&apos;: &apos;ccc&apos;, &apos;b&apos;: &apos;bbb&apos;&#125;OBJ = &#123;&#125; //errorOBJ[&apos;a&apos;] = &apos;aaa&apos; //成功赋值","categories":[{"name":"计算机","slug":"计算机","permalink":"http://yoursite.com/categories/计算机/"},{"name":"前端","slug":"计算机/前端","permalink":"http://yoursite.com/categories/计算机/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"脚本编程基础知识","slug":"脚本编程基础知识","date":"2018-01-08T03:01:48.000Z","updated":"2022-11-25T06:28:53.838Z","comments":true,"path":"2018/01/08/脚本编程基础知识/","link":"","permalink":"http://yoursite.com/2018/01/08/脚本编程基础知识/","excerpt":"","text":"你以为什么是脚本？&emsp;&emsp;不知道你有没有接触过高级编程语言，比如C、C++、Java等，这些语言的执行通常需要经过编写-编译-链接-运行等过程，而脚本语言则不然。一个脚本通常是解释运行而非编译。&emsp;&emsp;我们在维基百科上搜Script（脚本），得到的结果有两个——剧本和脚本程序。虽然说两个是不一样的东西，但依然是可以放在一起理解的。所谓的剧本，就是演员照着一步一步做的东西。比如下边的这一段&emsp;&emsp;而我们编程领域的脚本程序不是给人照着做的，而是给计算机照着做的。你输入指令，让计算机能够看懂，然后计算机为你一步一步执行这些指令。 让我们来试着写一个脚本？ 进入一个目录，然后新建脚本文件，一般脚本文件的后缀是.sh，但是它并没有什么用。在Windows下文件的后缀名决定着该文件的默认打开方式，但在命令行下，打开方式是我们手动指定的，比如vim demo.txt或者open -a &#39;Google Chrome&#39; demo.txt都是可以的。所以命令行下我们写后缀主要还是给我们自己看，让我们自己一眼就知道这个文件是个什么文件。&emsp;&emsp;我们在/f/wcy/local文件目录下建立一个demo.sh文件。 编辑demo.sh文件。vim demo.sh(当然，你也可以用其他方式打开然后编辑。或者你也可以写下其他的脚本代码。) 12345mkdir demo //新建一个名为demo的目录cd demo //进入demo这个目录mkdir css js //新建两个文件夹css和jstouch index.html css/style.css js/main.js //新建三个文件exit //退出 （Windows不需要）给demo.sh添加执行权限chmod +x demo.sh 在你需要执行该脚本的目录执行sh /f/wcy/local/demo.sh，然后你就可以在当前目录看到你需要的demo文件夹以及里边你使用脚本创建的文件了。 事实上，你可以现在结束这篇文章，因为你已经成功地运行了一个你自己写的脚本。但是，作为一名程序员，你还需要知道一些其他的东西。比如——把你的脚本文件目录添加到path中。&emsp;&emsp;玩过java的应该对path都不会太陌生，虽然可能并不能理解path的含义，但是多少都应该是听过的。这里我不想太深入写，只能说，path里边可以写一堆目录，我们每次输入命令的时候都会依次在这些目录里边查找有没有同名的文件，如果有就执行。&emsp;&emsp;type命令可以显示这个查找的过程。which命令可以告诉你查询最终的结果是什么，比如which mkdir在我这边执行的结果就是/usr/bin/mkdir。在计算机当中，所有的命令都是可执行文件，也就是，脚本。计算机中不可执行的文件是配置文件，就是我们常说的config文件。&emsp;&emsp;以上，我们只需要把/f/wcy/local（请修改成你的脚本文件存在的目录）添加到~/.bashrc（这个文件不解释了，以前解释过。常见问题合集，修改bash命令路径下有这个文件的作用，事实上你可以不用了解。）&emsp;&emsp;先进入local目录，输入pwd得到它的绝对路径。然后touch ~/.bashrc创建.bashrc文件。接着打开文件，在最后一行添加export PATH=&quot;local的绝对路径:$PATH&quot;。然后source ~/.bashrc。成功。之前你需要运行sh /f/wcy/local/demo.sh而现在你可以不需要输入路径直接运行sh demo.sh了。 仅仅是创建一个名为demo的文件夹会不会太单调了呢？让我们来加个参数吧！&emsp;&emsp;在bash里边，$1表示第一个参数，别问我怎么知道的，自己搜去。你只需要看懂下边的代码就好了，有需要的功能再去搜索。12345mkdir $1cd $1mkdir css jstouch index.html css/style.css js/main.jsexit &emsp;&emsp;现在，你可以运行sh demo.sh aa来创建一个名为aa的文件夹了。 如果说我已经创建过一个名为aa的文件夹，然后又来运行sh demo.sh aa呢？显而易见，它是会报错的。那么我们能不能不让它报那么难看的错，给用户一个提示信息呢？是的，加一个判断。如果这个文件存在，那么就让它输出”The directory is already exist!”，如果不存在那就创建。所以，你可以Google一下bash脚本的if语句怎么用。这里是代码。 1234567891011if [ -d $1 ]; then echo &apos;The directory is already exist!&apos; exit 1 //表示程序运行出错，错误代码为1else mkdir $1 cd $1 mkdir css js touch index.html css/style.css js/main.js echo &apos;success&apos; exit 0 //表示0个错误fi 是的，经过上述步骤基本已经完成了一个小脚本案例了。我们最后来进行测试环节。 12sh demo.sh aa &amp;&amp; echo &apos;成功&apos; //如果前边的程序执行成功就显示字符串“成功”sh demo.sh bb || echo &apos;失败&apos; //如果前边的程序返回的是非0，显示“失败” 换个node.js脚本玩玩？&emsp;&emsp;我们上边写的脚本是Bash Script（Bash脚本），现在，换个我们前端用的js脚本玩玩？基本规则其实都差不多，两个的语法方面略微有一点差别。你想要实现什么功能的话都可以去Google。比如你可以搜索node js change dir，来找到如何在node下转换路径。你也可以进入nodejs官网nodejs.org–&gt;docs–&gt;api直接在里边查，比如文件系统(file system—fs)的一些操作。1234node //先进入nodeprocess.chdir(&apos;F:\\\\wcy\\\\local&apos;) //改变系统路径到你需要的目录（这个路径写法是windows下的写法。。。保持微笑不吐槽）console.log(process.cwd()) //得到当前所处路径并打印出来console.log()相信你不会陌生。//Ctrl+D退出node环境 &emsp;&emsp;上边用bash命令我们执行写的是sh demo.sh，如果你省略sh直接写demo.sh依然可以得到你想要的结果。因为系统默认使用sh（即shell）来运行脚本。但到了这里可就不行了。你知道的，文件后缀并不影响，所以如果你依然用shell来执行demo.js文件，显然是有问题的。我们一般会用node demo.js来运行这个文件。如果你想让这个文件默认用node执行，请在文件的第一行加上#!/usr/bin/env node。综上，将上述功能换成js脚本的话，就应该是这样的：123456789101112131415#!/usr/bin/env nodevar fs = require(&apos;fs&apos;);dirName = process.argv[2] // 你传的参数是从第 2 个开始的if (fs.existsSync(dirName)) &#123; console.log(&quot;The file is already exist&quot;); process.exit(1);&#125; fs.mkdirSync(&quot;./&quot; + dirName) // mkdir $1 process.chdir(&quot;./&quot; + dirName) // cd $1 fs.mkdirSync(&apos;css&apos;) // mkdir css fs.mkdirSync(&apos;js&apos;) // mkdir js fs.writeFileSync(&quot;./index.html&quot;, &quot;&lt;!DOCTYPE&gt;&lt;title&gt;Hello&lt;/title&gt;&lt;h1&gt;Hi&lt;/h1&gt;&quot;) fs.writeFileSync(&quot;css/style.css&quot;, &quot;h1&#123;color: red;&#125;&quot;) fs.writeFileSync(&quot;./js/main.js&quot;, &quot;var string = &apos;Hello World&apos; alert(string)&quot;) process.exit(0) &emsp;&emsp;这里对第三行稍微解释一下，为什么前边bash传的参数算是第一个而后边js算是第二个呢？给一段代码吧，反正我是这样理解的。demo.sh xx，node demo.js xx，从0开始数。","categories":[{"name":"计算机","slug":"计算机","permalink":"http://yoursite.com/categories/计算机/"}],"tags":[{"name":"node.js","slug":"node-js","permalink":"http://yoursite.com/tags/node-js/"}]},{"title":"GitHub+Hexo快速搭建博客","slug":"GitHub-Hexo快速搭建博客","date":"2018-01-05T03:01:48.000Z","updated":"2022-11-25T06:28:53.835Z","comments":true,"path":"2018/01/05/GitHub-Hexo快速搭建博客/","link":"","permalink":"http://yoursite.com/2018/01/05/GitHub-Hexo快速搭建博客/","excerpt":"","text":"Hexo 是一个快速、简洁且高效的博客框架。事实上，你也可以选择上官网看教程。利用GitHub+Hexo我们可以快速搭建一个个人博客网站。以下是使用教程。 安装Hexo&emsp;&emsp;据说windows下极易安装失败，但是我的win10并没有出现什么问题。所以我不知道你们会出现什么问题我也不会解决。&emsp;&emsp;如果你的系统里已经安装过Node.js和Git的话，安装Hexo会是一件再简单不过的事情。如果没有安装过的话，请自行百度教程。然后再继续本篇内容。&emsp;&emsp;打开git bash，然后运行npm install -g hexo-cli。然后就安装完成了。 在GitHub上建立项目在GitHub上建立一个空的repo，名称是[你的用户名.github.io]，比如wenchuyang.github.io。 配置Hexo是的安装完成之后你需要配置它，依旧用命令行。 进入一个安全并且你能找得到的目录，比如cd ~/Desktop。 执行以下命令 123hexo init &lt;folder&gt; //folder是你自己的文件夹名称，比如hexo init myBlogcd &lt;folder&gt;npm install //或者简写为 npm i 您可以在_config.yml文件中修改大部分的配置。运行start _config.yml打开该文件，各参数如下。你需要把文件最后一行的type改成type: git，最后一行的后边新增一行，左边与type平齐，加上一行repo: 仓库地址（请将仓库地址改为「你的用户名.github.io」对应的仓库地址）。注意格式。其它请按照你自己的需求更改。 安装git部署插件。npm install hexo-deployer-git --save 部署网站。hexo deploy 写下你的第一篇blog hexo new 我的第一篇博客 复制显示的路径，使用start 路径来编辑它（windows给你显示的路径用的是”\\”，你需要手动将其改成”/“才能进入目录。[微笑]） hexo generate hexo deploy hexo server开启hexo服务，这样你就可以本地预览效果了。 切换主题我猜你一定不会喜欢它默认的主题，当然如果你无所谓的话请忽略这一步。 Hexo主题合集，找一个你喜欢的主题，进入主题的GitHub首页。 复制它的SSH地址，假设地址是git@github.com:iissnan/hexo-theme-next.git cd themes进入themes文件夹。 git clone git@github.com:iissnan/hexo-theme-next.git将项目克隆到你的本地themes文件夹 1234cd .. //退回到上层文件夹start _config.yml //打开配置文件，将 _config.yml 的第 75 行改为 theme: hexo-theme-next，保存hexo generatehexo deploy 等一分钟，然后刷新你的博客页面。 上传源码上边我们建的仓库保存的只是你的博客页面，并没有保存源码。所以如果你误删了这个本地的文件夹…..嗯，为了防止你手抖做出什么可怕的事情，我们需要在GitHub上继续新建一个项目，用来保存生成博客的源码。 在GitHub上创建blog-generator空仓库 初始化空仓库，GitHub上有详细的步骤，一步一步来即可。不多说了。温馨提示：你现在所在的目录应该是你的博客目录比如我的是myBlog，push到远程仓库的时候事实上你是将myBlog这整个的文件夹push上去。 以后每次hexo deploy之后博客就会更新，然后你记着add/commit/push将blog-generator同步更新就好了。 同时部署到gitee上 git deploy的时候同时更新github和gitee：在_config.yml文件中仓库地址的位置添加 12345deploy:- type: git repo: // 你的github对应的blog仓库地址- type: git repo: // 你的gitee对应的blog仓库地址 添加公钥，不然会被拒绝访问。 打开gitee页面预览打开你的仓库代码/服务/Gitee Pages，生成gitee page。 把你的gitee仓库名设置为你的用户名，这样生成的页面url是https://用户名[.gitee.io/，而且不会出现css不生效等系列问题。官方文档","categories":[{"name":"计算机","slug":"计算机","permalink":"http://yoursite.com/categories/计算机/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-01-05T03:01:48.000Z","updated":"2022-11-25T06:28:53.836Z","comments":true,"path":"2018/01/05/hello-world/","link":"","permalink":"http://yoursite.com/2018/01/05/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"计算机","slug":"计算机","permalink":"http://yoursite.com/categories/计算机/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"}]}],"categories":[{"name":"计算机","slug":"计算机","permalink":"http://yoursite.com/categories/计算机/"},{"name":"前端","slug":"计算机/前端","permalink":"http://yoursite.com/categories/计算机/前端/"},{"name":"HTML","slug":"计算机/前端/HTML","permalink":"http://yoursite.com/categories/计算机/前端/HTML/"},{"name":"react","slug":"计算机/前端/react","permalink":"http://yoursite.com/categories/计算机/前端/react/"},{"name":"书籍","slug":"书籍","permalink":"http://yoursite.com/categories/书籍/"},{"name":"写作","slug":"书籍/写作","permalink":"http://yoursite.com/categories/书籍/写作/"}],"tags":[{"name":"网络安全","slug":"网络安全","permalink":"http://yoursite.com/tags/网络安全/"},{"name":"面试","slug":"面试","permalink":"http://yoursite.com/tags/面试/"},{"name":"nvm","slug":"nvm","permalink":"http://yoursite.com/tags/nvm/"},{"name":"工具使用","slug":"工具使用","permalink":"http://yoursite.com/tags/工具使用/"},{"name":"onClick","slug":"onClick","permalink":"http://yoursite.com/tags/onClick/"},{"name":"发布-订阅模式","slug":"发布-订阅模式","permalink":"http://yoursite.com/tags/发布-订阅模式/"},{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"},{"name":"ref","slug":"ref","permalink":"http://yoursite.com/tags/ref/"},{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"},{"name":"Hooks","slug":"Hooks","permalink":"http://yoursite.com/tags/Hooks/"},{"name":"生命周期","slug":"生命周期","permalink":"http://yoursite.com/tags/生命周期/"},{"name":"react-router","slug":"react-router","permalink":"http://yoursite.com/tags/react-router/"},{"name":"context","slug":"context","permalink":"http://yoursite.com/tags/context/"},{"name":"redux","slug":"redux","permalink":"http://yoursite.com/tags/redux/"},{"name":"react-redux","slug":"react-redux","permalink":"http://yoursite.com/tags/react-redux/"},{"name":"组件通信","slug":"组件通信","permalink":"http://yoursite.com/tags/组件通信/"},{"name":"eventHub","slug":"eventHub","permalink":"http://yoursite.com/tags/eventHub/"},{"name":"create-react-app","slug":"create-react-app","permalink":"http://yoursite.com/tags/create-react-app/"},{"name":"babel","slug":"babel","permalink":"http://yoursite.com/tags/babel/"},{"name":"Cookie","slug":"Cookie","permalink":"http://yoursite.com/tags/Cookie/"},{"name":"LocalStorage","slug":"LocalStorage","permalink":"http://yoursite.com/tags/LocalStorage/"},{"name":"Session","slug":"Session","permalink":"http://yoursite.com/tags/Session/"},{"name":"Cache-Control","slug":"Cache-Control","permalink":"http://yoursite.com/tags/Cache-Control/"},{"name":"ETag","slug":"ETag","permalink":"http://yoursite.com/tags/ETag/"},{"name":"书籍","slug":"书籍","permalink":"http://yoursite.com/tags/书籍/"},{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"},{"name":"写作方法","slug":"写作方法","permalink":"http://yoursite.com/tags/写作方法/"},{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"node.js","slug":"node-js","permalink":"http://yoursite.com/tags/node-js/"}]}